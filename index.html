<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <!-- <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' https: data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https:; style-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; font-src 'self' https:; connect-src 'self' https:;"> -->
    <title>Omega Terminal - Mining Interface</title>
    <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js" type="application/javascript"></script>
    <script src="https://cdn.jsdelivr.net/npm/eth-crypto@2.1.2/dist/lib.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            overflow: hidden;
        }

        .terminal {
            width: 100vw;
            height: 100dvh;
            padding: 20px;
            background: linear-gradient(135deg, #000 0%, #111111 100%);
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .terminal-header {
            border-bottom: 1px solid #ffffff;
            padding-bottom: 10px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .terminal-title {
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 15px #ffffff, 0 0 30px #ffffff;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .terminal-status {
            font-size: 12px;
            color: #cccccc;
        }

        .theme-toggle {
            width: 22px;
            height: 22px;
            background: transparent;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            margin-right: 0;
            margin-left: 0;
            display: inline-block;
            transition: border-color 0.2s;
            box-sizing: border-box;
            outline: none;
        }

        .theme-toggle:hover {
            border-color: #99ccff;
            background: rgba(255,255,255,0.05);
        }

        .terminal-input-section {
            border-top: 1px solid #ffffff;
            padding-top: 10px;
            margin-top: auto;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ffffff;
        }

        .terminal-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 10px;
            margin-bottom: 20px;
            user-select: text !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
        }

        .terminal-line {
            margin-bottom: 5px;
            word-wrap: break-word;
        }

        .prompt {
            color: #ffffff;
            font-weight: bold;
        }

        .command {
            color: #ffffff;
        }

        .output {
            color: #cccccc;
            margin-left: 20px;
            user-select: text !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
        }

        .error {
            color: #ff6666;
        }

        .success {
            color: #ffffff;
        }

        .warning {
            color: #ffffcc;
        }

        .info {
            color: #99ccff;
        }

        .mining-status {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #ffffff;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #111111;
            border: 1px solid #ffffff;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffffff, #cccccc);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px #ffffff;
        }

        .input-line {
            display: flex;
            align-items: center;
            background: transparent;
        }

        .input-prompt {
            color: #ffffff;
            font-weight: bold;
            margin-right: 10px;
            font-size: 16px;
        }

        .input-field {
            background: transparent;
            border: none;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            outline: none;
            flex: 1;
            padding: 5px;
        }

        .input-field::placeholder {
            color: #666666;
        }

        .cursor {
            animation: blink 1s infinite;
            color: #ffffff;
            font-size: 16px;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .mining-animation {
            display: inline-block;
            animation: mining-pulse 2s infinite;
        }

        @keyframes mining-pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #ffffff;
            padding: 10px;
            border-radius: 5px;
        }

        .stat-label {
            color: #cccccc;
            font-size: 12px;
        }

        .stat-value {
            color: #ffffff;
            font-size: 16px;
            font-weight: bold;
        }

        /* Boot Animation Styles */
        .boot-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-family: 'Courier New', monospace;
        }

        .omega-symbols {
            font-size: 48px;
            color: #ffffff;
            text-shadow: 0 0 20px #ffffff;
            margin-bottom: 20px;
            animation: omega-float 3s ease-in-out infinite;
        }

        .pickaxe {
            font-size: 36px;
            color: #ffcc00;
            text-shadow: 0 0 15px #ffcc00;
            animation: pickaxe-swing 2s ease-in-out infinite;
            margin-bottom: 30px;
        }

        .welcome-text {
            font-size: 24px;
            color: #ffffff;
            text-align: center;
            line-height: 1.5;
            text-shadow: 0 0 10px #ffffff;
        }

        .loading-dots {
            font-size: 18px;
            color: #cccccc;
            margin-top: 20px;
            animation: loading-pulse 1.5s ease-in-out infinite;
        }

        @keyframes omega-float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        @keyframes pickaxe-swing {
            0%, 100% { transform: rotate(-15deg); }
            50% { transform: rotate(15deg); }
        }

        @keyframes loading-pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .hidden {
            display: none !important;
        }

        /* Light Theme Styles */
        .terminal.light-theme {
            background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);
            color: #000000;
        }

        .terminal.light-theme .terminal-header {
            border-bottom: 1px solid #000000;
        }

        .terminal.light-theme .terminal-title {
            color: #000000;
            text-shadow: 0 0 15px #000000, 0 0 30px #000000;
        }

        .terminal.light-theme .terminal-status {
            color: #333333;
        }

        .terminal.light-theme .theme-toggle {
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid #000000;
            color: #000000;
        }

        .terminal.light-theme .theme-toggle:hover {
            background: rgba(0, 0, 0, 0.2);
        }

        .terminal.light-theme .terminal-input-section {
            border-top: 1px solid #000000;
            background: rgba(0, 0, 0, 0.05);
            border: 1px solid #000000;
        }

        .terminal.light-theme .prompt {
            color: #000000;
        }

        .terminal.light-theme .command {
            color: #000000;
        }

        .terminal.light-theme .output {
            color: #333333;
        }

        .terminal.light-theme .error {
            color: #cc0000;
        }

        .terminal.light-theme .success {
            color: #000000;
        }

        .terminal.light-theme .warning {
            color: #cc6600;
        }

        .terminal.light-theme .info {
            color: #0066cc;
        }

        .terminal.light-theme .input-prompt {
            color: #000000;
        }

        .terminal.light-theme .input-field {
            color: #000000;
        }

        .terminal.light-theme .input-field::placeholder {
            color: #666666;
        }

        .terminal.light-theme .cursor {
            color: #000000;
        }

        .terminal.light-theme .mining-status {
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid #000000;
        }

        .terminal.light-theme .stat-box {
            background: rgba(0, 0, 0, 0.05);
            border: 1px solid #000000;
        }

        .terminal.light-theme .stat-label {
            color: #333333;
        }

        .terminal.light-theme .stat-value {
            color: #000000;
        }

        .output.error {
            color: #ff3333 !important;
            font-weight: bold !important;
        }

        /* --- FORCE RED AND BOLD FOR ERROR OUTPUT --- */
        .terminal-content .output.error,
        .output.error {
            color: #ff3333 !important;
            font-weight: bold !important;
        }

        .terminal-content, .output, .output.error, .output.success, .output.info, .output.warning,
        .terminal-content *, .output *, .output.error *, .output.success *, .output.info *, .output.warning * {
            user-select: text !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
        }

        .terminal-line .copyable {
            cursor: pointer;
            text-decoration: underline;
            color: #00ff00;
            transition: all 0.3s ease;
        }
        
        .terminal-line .copyable:hover {
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00;
        }
        
        .terminal-line .copyable:active {
            color: #ff0000;
        }

        body.theme-dark {
            background: #000;
            color: #fff;
        }
        body.theme-light {
            background: #fff;
            color: #111;
        }
        body.theme-matrix {
            background: #000;
            color: #00ff00;
        }
        body.theme-retro {
            background: #111;
            color: #39ff14;
        }
        .theme-matrix .terminal-header, .theme-retro .terminal-header {
            border-bottom: 1px solid #00ff00;
        }
        .theme-matrix .input-prompt, .theme-retro .input-prompt {
            color: #39ff14;
        }
        .theme-retro .input-prompt {
            color: orange;
        }

        /* Matrix Theme Styles */
        body.theme-matrix {
            background: #000 !important;
            color: #00ff00 !important;
        }
        body.theme-matrix .terminal {
            background: #000 !important;
            color: #00ff00 !important;
        }
        body.theme-matrix .terminal-header {
            border-bottom: 1px solid #00ff00 !important;
        }
        body.theme-matrix .prompt,
        body.theme-matrix .input-prompt {
            color: #00ff00 !important;
            font-weight: bold;
        }
        body.theme-matrix .command {
            color: #00ff00 !important;
        }
        body.theme-matrix .output {
            color: #00ff00 !important;
        }
        body.theme-matrix .error {
            color: #ff3333 !important;
        }
        body.theme-matrix .success {
            color: #00ff00 !important;
        }
        body.theme-matrix .warning {
            color: #ffff00 !important;
        }
        body.theme-matrix .info {
            color: #00ffff !important;
        }

        /* Retro Theme Styles */
        body.theme-retro {
            background: #181200 !important;
            color: #39ff14 !important;
        }
        body.theme-retro .terminal {
            background: #181200 !important;
            color: #39ff14 !important;
        }
        body.theme-retro .terminal-header {
            border-bottom: 1px solid #ffaa00 !important;
        }
        body.theme-retro .prompt,
        body.theme-retro .input-prompt {
            color: #ffaa00 !important;
            font-weight: bold;
        }
        body.theme-retro .command {
            color: #39ff14 !important;
        }
        body.theme-retro .output {
            color: #39ff14 !important;
        }
        body.theme-retro .error {
            color: #ff3333 !important;
        }
        body.theme-retro .success {
            color: #ffaa00 !important;
        }
        body.theme-retro .warning {
            color: #ffff00 !important;
        }
        body.theme-retro .info {
            color: #00ffff !important;
        }

        body.theme-retro .info {
            color: #00ffff !important;
        }

        .omega-test-wallet-prompt {
            color: #fff !important;
            font-size: 1.5em !important;
            font-weight: bold;
            margin: 16px 0;
            display: block;
        }
    </style>
</head>
<body>
    <!-- Boot Animation -->
    <div class="boot-animation" id="bootAnimation">
        <div class="omega-symbols">Ω Ω Ω Ω Ω</div>
        <div class="pickaxe">⛏️</div>
        <div class="welcome-text">
            Welcome to Omega Terminal v1<br>
            <span style="font-size: 16px; color: #cccccc;">Type below to get started</span>
        </div>
        <div class="loading-dots">Loading...</div>
    </div>

    <div class="terminal" id="terminal" style="display: none;">
        <div class="terminal-header">
            <div class="terminal-title">Omega Terminal v1.0.5</div>
            <div style="display: flex; align-items: center; gap: 18px; margin-left: auto;">
                <button class="theme-toggle" title="Toggle Theme"></button>
                <div class="terminal-status" id="connectionStatus">DISCONNECTED</div>
            </div>
        </div>
        
        <!-- Faucet Info Box -->
        <div id="faucetInfoBox" style="background: rgba(0, 153, 255, 0.10); border: 1px solid #99ccff; color: #99ccff; padding: 10px 16px; border-radius: 6px; margin: 0 0 12px 0; font-size: 15px;">
            <b>Note:</b> Each wallet can only claim from the faucet once every 24 hours.<br>
            If you try to claim again before the cooldown is over, the transaction will fail.
        </div>
        <div class="terminal-content" id="terminalContent"></div>
        <div class="terminal-input-section">
            <div class="input-line">
                <span class="input-prompt">root@omega-miner:~$</span>
                <input type="text" class="input-field" id="commandInput" placeholder="Enter command..." autocomplete="off">
                <span class="cursor">|</span>
            </div>
        </div>
    </div>

    <script>
        // At the top of the main script, add a constant for the relayer URL:
        const RELAYER_URL = 'http://localhost:1000';

        // Simplified ethers loading with fallback support
        function loadEthers() {
            return new Promise((resolve, reject) => {
                // Small delay to ensure CDN script has time to load
                setTimeout(() => {
                    console.log('Checking for ethers availability...');
                    
                    // Check if ethers is already loaded (CDN success)
                    if (typeof ethers !== 'undefined') {
                        console.log('Ethers loaded successfully from CDN');
                        resolve(ethers);
                        return;
                    }
                    
                    console.log('CDN ethers not loaded, trying additional CDN sources...');
                    
                    // Try multiple CDN sources
                    const cdnSources = [
                        'https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js',
                        'https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js'
                    ];
                    
                    let currentSource = 0;
                    
                    function tryNextSource() {
                        if (currentSource >= cdnSources.length) {
                            // All CDN sources failed, load fallback
                            console.log('All CDN sources failed, loading fallback ethers...');
                            loadEthersFallback();
                            resolve(ethers);
                            return;
                        }
                        
                        const script = document.createElement('script');
                        script.src = cdnSources[currentSource];
                        script.onload = () => {
                            if (typeof ethers !== 'undefined') {
                                console.log(`Ethers loaded successfully from: ${cdnSources[currentSource]}`);
                                resolve(ethers);
                            } else {
                                currentSource++;
                                tryNextSource();
                            }
                        };
                        script.onerror = () => {
                            console.warn(`Failed to load ethers from: ${cdnSources[currentSource]}`);
                            currentSource++;
                            tryNextSource();
                        };
                        document.head.appendChild(script);
                    }
                    
                    tryNextSource();
                }, 500); // 500ms delay to ensure CDN script has time to load
            });
        }

        // Fallback ethers implementation - only loads if all CDN sources fail
        function loadEthersFallback() {
            console.log('Loading ethers fallback...');
            window.ethers = {
                providers: {
                    Web3Provider: function(provider) {
                        this.provider = provider;
                        this.getSigner = () => ({ 
                            getAddress: () => Promise.resolve('0x0000000000000000000000000000000000000000'),
                            sendTransaction: () => Promise.reject(new Error('Fallback ethers - no real transactions'))
                        });
                        this.getGasPrice = () => Promise.resolve({ toString: () => '20000000000' });
                        this.getBalance = () => Promise.resolve({ isZero: () => true });
                        this.getTransactionCount = () => Promise.resolve(0);
                    }
                },
                Contract: function(address, abi, signer) {
                    this.address = address;
                    this.abi = abi;
                    this.signer = signer;
                    // Add basic contract methods
                    this.startMining = () => Promise.resolve({ wait: () => Promise.resolve() });
                    this.claimRewards = () => Promise.resolve({ wait: () => Promise.resolve() });
                },
                Wallet: {
                    createRandom: function() {
                        return {
                            address: '0x' + Math.random().toString(16).substr(2, 40),
                            privateKey: '0x' + Math.random().toString(16).substr(2, 64),
                            connect: function(provider) { return this; },
                            sendTransaction: function(tx) { 
                                return Promise.resolve({ 
                                    hash: '0x' + Math.random().toString(16).substr(2, 64),
                                    wait: () => Promise.resolve()
                                }); 
                            }
                        };
                    }
                },
                utils: {
                    formatEther: (wei) => (parseInt(wei) / 1e18).toString(),
                    parseEther: (ether) => (parseFloat(ether) * 1e18).toString(),
                    id: (text) => '0x' + Math.random().toString(16).substr(2, 64),
                    defaultAbiCoder: {
                        decode: () => ['0x0000000000000000000000000000000000000000', '1000000000000000000', '1']
                    },
                    hexDataSlice: (data, start) => data
                }
            };
            console.log('Ethers fallback loaded successfully');
        }

        class OmegaMinerTerminal {
            constructor() {
                this.provider = null;
                this.signer = null;
                this.contract = null;
                this.isMining = false;
                this.miningInterval = null;
                this.currentNonce = 0;
                this.ethers = null;
                this.isDarkTheme = true; // Default to dark theme
                
                // New mining system properties
                this.pendingClaimableBalance = 0;
                this.totalEarned = 0; // Track total earned during session
                this.waitingForContinueResponse = false;
                
                // Stress test properties
                this.isStressTesting = false;
                this.stressTestInterval = null;
                this.stressTestStats = {
                    walletsCreated: 0,
                    transactionsSent: 0,
                    successfulTxs: 0,
                    failedTxs: 0,
                    startTime: 0
                };
                this.stressWallet = null;
                this.stressNonce = 0;
                
                // Contract properties
                this.contractAddress = "0x54c731627f2d2b55267b53e604c869ab8e6a323b"; // SimpleMiner contract with claimTo
                this.faucetAddress = "0xf8e00f8cfaccf9b95f703642ec589d1c6ceee1a9"; // Update faucet contract address
                this.minerFaucetAddress = '0x1c4ffffcc804ba265f6cfccffb94d0ae28b36207'; // Deployed OmegaMinerFaucet contract
                this.contractABI = [
                    "function mineBlock(uint256 nonce, bytes32 solution) external",
                    "function claimRewards() external",
                    "function claimTo(address recipient) external",
                    "function getMinerInfo(address miner) external view returns (uint256 _totalMined, uint256 _lastMineTime, uint256 _pendingRewards)",
                    "function calculateReward(address miner, uint256 nonce, bytes32 solution) external view returns (uint256)",
                    "function cooldownPeriod() external view returns (uint256)",
                    "function totalRewardsDistributed() external view returns (uint256)",
                    "function owner() external view returns (address)",
                    "function setCooldownPeriod(uint256 _cooldown) external",
                    "function withdrawExcess() external",
                    "event BlockMined(address indexed miner, uint256 nonce, bytes32 solution, uint256 reward)",
                    "event RewardsClaimed(address indexed miner, uint256 amount)"
                ];
                this.faucetABI = [
                    {
                        "inputs": [],
                        "name": "claim",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    },
                    {
                        "inputs": [
                            { "internalType": "address", "name": "user", "type": "address" }
                        ],
                        "name": "getFaucetStatus",
                        "outputs": [
                            { "internalType": "bool", "name": "canClaimNow", "type": "bool" },
                            { "internalType": "uint256", "name": "lastClaim", "type": "uint256" },
                            { "internalType": "uint256", "name": "timeUntilNextClaim", "type": "uint256" },
                            { "internalType": "uint256", "name": "claimAmount", "type": "uint256" },
                            { "internalType": "uint256", "name": "faucetBalance", "type": "uint256" },
                            { "internalType": "uint256", "name": "totalClaims_", "type": "uint256" }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "emergencyWithdraw",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "stateMutability": "nonpayable",
                        "type": "constructor"
                    },
                    {
                        "anonymous": false,
                        "inputs": [
                            {
                                "indexed": false,
                                "internalType": "uint256",
                                "name": "amount",
                                "type": "uint256"
                            }
                        ],
                        "name": "FaucetRefilled",
                        "type": "event"
                    },
                    {
                        "inputs": [],
                        "name": "refillFaucet",
                        "outputs": [],
                        "stateMutability": "payable",
                        "type": "function"
                    },
                    {
                        "anonymous": false,
                        "inputs": [
                            {
                                "indexed": true,
                                "internalType": "address",
                                "name": "user",
                                "type": "address"
                            },
                            {
                                "indexed": false,
                                "internalType": "uint256",
                                "name": "amount",
                                "type": "uint256"
                            },
                            {
                                "indexed": false,
                                "internalType": "uint256",
                                "name": "timestamp",
                                "type": "uint256"
                            }
                        ],
                        "name": "TokensClaimed",
                        "type": "event"
                    },
                    {
                        "inputs": [],
                        "name": "withdrawFaucet",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    },
                    {
                        "stateMutability": "payable",
                        "type": "receive"
                    },
                    {
                        "inputs": [
                            {
                                "internalType": "address",
                                "name": "user",
                                "type": "address"
                            }
                        ],
                        "name": "canClaim",
                        "outputs": [
                            {
                                "internalType": "bool",
                                "name": "",
                                "type": "bool"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "CLAIM_AMOUNT",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "CLAIM_COOLDOWN",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "faucetBalance",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [
                            {
                                "internalType": "address",
                                "name": "user",
                                "type": "address"
                            }
                        ],
                        "name": "getClaimInfo",
                        "outputs": [
                            {
                                "internalType": "bool",
                                "name": "canClaimNow",
                                "type": "bool"
                            },
                            {
                                "internalType": "uint256",
                                "name": "lastClaim",
                                "type": "uint256"
                            },
                            {
                                "internalType": "uint256",
                                "name": "timeUntilNextClaim",
                                "type": "uint256"
                            },
                            {
                                "internalType": "uint256",
                                "name": "claimAmount",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "getFaucetBalance",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [
                            {
                                "internalType": "address",
                                "name": "user",
                                "type": "address"
                            }
                        ],
                        "name": "getTimeUntilNextClaim",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [
                            {
                                "internalType": "address",
                                "name": "",
                                "type": "address"
                            }
                        ],
                        "name": "lastClaimTime",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [],
                        "name": "totalClaims",
                        "outputs": [
                            {
                                "internalType": "uint256",
                                "name": "",
                                "type": "uint256"
                            }
                        ],
                        "stateMutability": "view",
                        "type": "function"
                    }
                ];
                this.minerFaucetABI = [
                    {
                        "inputs": [],
                        "name": "mine",
                        "outputs": [],
                        "stateMutability": "payable",
                        "type": "function"
                    },
                    {
                        "inputs": [{"internalType": "address", "name": "", "type": "address"}],
                        "name": "totalMined",
                        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                        "stateMutability": "view",
                        "type": "function"
                    },
                    {
                        "inputs": [{"internalType": "address", "name": "", "type": "address"}],
                        "name": "lastMineTime",
                        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                        "stateMutability": "view",
                        "type": "function"
                    }
                ];
                
                this.loadTheme();
                this.init();

                // In the OmegaMinerTerminal class:
                // 1. Add DM prompt state variables to the constructor
                this.awaitingDMRecipient = false;
                this.awaitingDMMessage = false;
                this.tempDMRecipient = '';
            }
            
            async init() {
                this.log('DEBUG: init() started', 'info');
                // Show boot animation first
                await this.showBootAnimation();
                // Always set up event listeners immediately after boot
                this.setupEventListeners();
                try {
                    console.log('Loading ethers library...');
                    this.ethers = await loadEthers();
                    console.log('Ethers library loaded successfully');
                    this.log('Ethers library loaded successfully', 'success');
                    this.log('DEBUG: About to check for MetaMask', 'info');
                    const hasMetaMask = await this.isRealMetaMask();
                    this.log('DEBUG: hasMetaMask = ' + hasMetaMask, 'info');
                    let walletReady = false;
                    if (!hasMetaMask) {
                        this.log('DEBUG: Inside MetaMask not detected block', 'info');
                        this.log('Error checking wallet connection: MetaMask not detected', 'error');
                        this.logHtml('<span class="omega-test-wallet-prompt">Would you prefer an Omega Test Wallet? (yes / no)</span>', 'info');
                        let resolved = false;
                        while (!resolved) {
                            const input = await this.promptTerminalInput();
                            const choice = input.trim().toLowerCase();
                            if (choice === 'yes') {
                                // Set up a public RPC provider (Aurora mainnet as example)
                                const OMEGA_RPC_URL = 'https://0x4e454228.rpc.aurora-cloud.dev';
                                this.provider = new this.ethers.providers.JsonRpcProvider(OMEGA_RPC_URL);
                                this.sessionOmegaWallet = this.ethers.Wallet.createRandom();
                                this.signer = this.sessionOmegaWallet.connect(this.provider);
                                // Connect mining contract for session wallet
                                if (this.contractAddress && this.contractABI) {
                                    this.contract = new this.ethers.Contract(this.contractAddress, this.contractABI, this.signer);
                                    this.log('Mining contract connected for Omega Test Wallet.', 'success');
                                }
                                this.log('DEBUG: Omega wallet created and provider set', 'info');
                                this.logHtml('<span style="color:#ff3333;font-weight:bold;">This is currently in beta. We recommend you transfer any OMEGA tokens you receive to a MetaMask wallet for safekeeping. Do NOT use this wallet for large amounts or long-term storage.</span>', 'error');
                                const addr = this.sessionOmegaWallet.address;
                                const privKey = this.sessionOmegaWallet.privateKey;
                                this.logHtml(`<span style='color:#33bbff'>Omega Wallet Address:</span> <span style='color:#fff'>${addr}</span> <button onclick=\"navigator.clipboard.writeText('${addr}')\">Copy</button>`, 'info');
                                // Add private key reveal below address
                                this.logHtml(`<span style='color:#ff3333'>Omega Private Key [Never Share]:</span> <span id='privkey-reveal' style='color:#fff'><button onclick=\"this.style.display='none';document.getElementById('privkey-value').style.display='inline'\">Click to Reveal</button><span id='privkey-value' style='display:none;'>${privKey} <button onclick=\"navigator.clipboard.writeText('${privKey}')\">Copy</button></span></span>`, 'error');
                                this.log('Requesting funds for your Omega Test Wallet from the relayer...', 'info');
                                await fundOmegaWallet(addr);
                                this.log('If you do not see a funding confirmation above, please check your relayer or network connection.', 'info');
                                resolved = true;
                                walletReady = true;
                            } else if (choice === 'no') {
                                this.log('Please install MetaMask to use the Omega Terminal.', 'error');
                                this.logHtml('<a href="https://metamask.io/download.html" target="_blank">Download MetaMask</a>', 'info');
                                // Stop further initialization
                                return;
                            } else {
                                this.log('Please type either "yes" or "no".', 'warning');
                            }
                        }
                    } else {
                        // MetaMask detected, proceed as usual
                        walletReady = true;
                    }
                    // Only proceed if a wallet is set up
                    if (walletReady) {
                        if (hasMetaMask) {
                    this.checkWalletConnection();
                        }
                    }
                } catch (error) {
                    console.error('Failed to load ethers:', error);
                    this.log('Failed to load ethers library: ' + error.message, 'error');
                    this.log('Please check your internet connection and refresh the page', 'error');
                }
            }
            
            loadTheme() {
                const theme = localStorage.getItem('omega-terminal-theme') || 'dark';
                document.body.classList.remove('theme-dark', 'theme-light', 'theme-matrix', 'theme-retro');
                document.body.classList.add('theme-' + theme);
                const terminal = document.getElementById('terminal');
                if (terminal) {
                    terminal.classList.remove('theme-dark', 'theme-light', 'theme-matrix', 'theme-retro');
                    terminal.classList.add('theme-' + theme);
                }
                localStorage.setItem('omega-terminal-theme', theme);
                this.log(`Theme set to ${theme} mode`, 'success');
            }
            
            async showBootAnimation() {
                console.log('Showing boot animation...');
                return new Promise((resolve) => {
                    setTimeout(() => {
                        console.log('Hiding boot animation, showing terminal...');
                        // Hide boot animation and show terminal
                        document.getElementById('bootAnimation').style.display = 'none';
                        document.getElementById('terminal').style.display = 'flex';
                        
                        // Apply theme after terminal is shown
                        this.applyTheme();
                        
                        // Show unified help
                        this.showUnifiedHelp();
                        
                        console.log('Terminal ready!');
                        resolve();
                    }, 3000); // Show animation for 3 seconds
                });
            }
            
            setupEventListeners() {
                const input = document.getElementById('commandInput');
                if (input) {
                    input.focus();
                    // Command history and autocomplete state
                    this.commandHistory = [];
                    this.historyIndex = -1;
                    this.lastInputValue = '';
                    this.availableCommands = [
                        'help', 'clear', 'connect', 'disconnect', 'balance', 'faucet', 'mine', 'claim', 'status', 'stats',
                        'send', 'ens', 'mixer', 'stress', 'stopstress', 'stressstats', 'theme', 'rickroll', 'fortune', 'matrix', 'hack', 'disco', 'sudo mine', 'clob', 'v2', 'stop',
                        'email', 'inbox', 'dexscreener', 'geckoterminal', 'stock', 'alphakey', 'ds', 'cg', 'alpha'
                    ];
                    input.addEventListener('keydown', (e) => {
                        // Up arrow: previous command
                        if (e.key === 'ArrowUp') {
                            if (this.commandHistory.length > 0) {
                                if (this.historyIndex === -1) {
                                    this.historyIndex = this.commandHistory.length - 1;
                                    this.lastInputValue = input.value;
                                } else if (this.historyIndex > 0) {
                                    this.historyIndex--;
                                }
                                input.value = this.commandHistory[this.historyIndex];
                                setTimeout(() => input.setSelectionRange(input.value.length, input.value.length), 0);
                            }
                            e.preventDefault();
                        }
                        // Down arrow: next command or clear
                        if (e.key === 'ArrowDown') {
                            if (this.commandHistory.length > 0 && this.historyIndex !== -1) {
                                if (this.historyIndex < this.commandHistory.length - 1) {
                                    this.historyIndex++;
                                    input.value = this.commandHistory[this.historyIndex];
                                } else {
                                    this.historyIndex = -1;
                                    input.value = this.lastInputValue || '';
                                }
                                setTimeout(() => input.setSelectionRange(input.value.length, input.value.length), 0);
                            }
                            e.preventDefault();
                        }
                        // Tab: autocomplete
                        if (e.key === 'Tab') {
                            e.preventDefault();
                            const val = input.value.trim();
                            if (!val) return;
                            const matches = this.availableCommands.filter(cmd => cmd.startsWith(val));
                            if (matches.length === 1) {
                                input.value = matches[0] + ' ';
                            } else if (matches.length > 1) {
                                this.logHtml('<span style="color:#cccccc">' + matches.join('    ') + '</span>', 'info');
                            }
                        }
                    });
                    input.addEventListener('keypress', async (e) => {
                        if (e.key === 'Enter') {
                            const val = input.value;
                            input.value = '';
                            if (this.awaitingPromptInput && this.promptResolver) {
                                const value = val.trim();
                                this.awaitingPromptInput = false;
                                this.promptResolver(value);
                                this.promptResolver = null;
                            } else {
                                if (val.trim()) {
                                    this.commandHistory.push(val.trim());
                                    if (this.commandHistory.length > 100) this.commandHistory.shift();
                                }
                                this.historyIndex = -1;
                                this.lastInputValue = '';
                                await this.executeCommand(val);
                            }
                        }
                        // Ctrl+C to stop stress test
                        if (e.key === 'c' && e.ctrlKey) {
                            // 'this' is not needed here, as isStressTesting is not used in this context
                        }
                    });
                    // Fallback: refocus input if user clicks anywhere in the terminal
                    document.getElementById('terminal').addEventListener('click', function() {
                        input.focus();
                    });
                }
                // Setup theme toggle
                const themeToggle = document.querySelector('.theme-toggle');
                if (themeToggle) {
                    themeToggle.addEventListener('click', () => {
                        this.toggleTheme();
                    });
                    // Remove emoji/text, just hollow circle
                    themeToggle.textContent = '';
                }
            }
            
            async checkWalletConnection() {
                if (typeof window.ethereum !== 'undefined') {
                    try {
                        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                        if (accounts.length > 0) {
                            await this.connectWallet();
                        }
                    } catch (error) {
                        this.log('Error checking wallet connection: ' + error.message, 'error');
                    }
                }
            }
            
            async connectWallet() {
                try {
                    if (!this.ethers) {
                        this.log('Ethers library not loaded. Please refresh the page.', 'error');
                        return;
                    }

                    if (typeof window.ethereum === 'undefined') {
                        this.log('MetaMask not found. Please install MetaMask.', 'error');
                        return;
                    }
                    
                    this.log('🔗 Connecting to MetaMask...', 'info');
                    
                    // Request account access
                    try {
                        await window.ethereum.request({ method: 'eth_requestAccounts' });
                        this.log('✅ MetaMask account access granted', 'success');
                    } catch (requestError) {
                        this.log('❌ MetaMask connection denied by user', 'error');
                        return;
                    }
                    
                    this.provider = new this.ethers.providers.Web3Provider(window.ethereum);
                    this.signer = this.provider.getSigner();
                    
                    this.log('🔍 Getting wallet address...', 'info');
                    const address = await this.signer.getAddress();
                    
                    // Check if we're using fallback ethers (which would return 0x000... address)
                    if (address === '0x0000000000000000000000000000000000000000') {
                        this.log('⚠️ Using fallback ethers - real transactions not available', 'warning');
                        this.log('💡 Please check your internet connection and refresh the page', 'info');
                        return;
                    }
                    
                    this.log(`✅ Wallet connected: ${address}`, 'success');
                    this.updateConnectionStatus('CONNECTED');
                    
                    if (this.contractAddress !== '0x0000000000000000000000000000000000000000') {
                        this.contract = new this.ethers.Contract(this.contractAddress, this.contractABI, this.signer);
                        this.log('✅ Mining contract connected', 'success');
                    }
                    
                } catch (error) {
                    console.error('Connect wallet error:', error);
                    this.log('❌ Failed to connect wallet: ' + error.message, 'error');
                    this.log('💡 Make sure MetaMask is unlocked and you approve the connection', 'info');
                }
            }
            
            async disconnectWallet() {
                try {
                    if (!this.signer) {
                        this.log('No wallet connected to disconnect.', 'warning');
                        return;
                    }
                    
                    // Get the address before disconnecting for the message
                    const address = await this.signer.getAddress();
                    
                    // Clear all wallet-related properties
                    this.provider = null;
                    this.signer = null;
                    this.contract = null;
                    this.pendingClaimableBalance = 0;
                    
                    this.log(`🔌 Wallet disconnected: ${address}`, 'success');
                    this.updateConnectionStatus('DISCONNECTED');
                    this.log('💡 Use "connect" command to reconnect your wallet', 'info');
                    
                } catch (error) {
                    console.error('Disconnect wallet error:', error);
                    this.log('❌ Error disconnecting wallet: ' + error.message, 'error');
                }
            }
            
            async executeCommand(command) {
                if (this.awaitingPromptInput) return;
                // At the top of executeCommand, before command parsing:
                if (this.awaitingDMRecipient) {
                    this.tempDMRecipient = command.trim();
                    this.awaitingDMRecipient = false;
                    this.awaitingDMMessage = true;
                    this.logHtml('<span style="color:#99ccff">Recipient:</span> <span style="color:#fff">' + this.tempDMRecipient + '</span>', 'info');
                    this.log('Enter your message:', 'info');
                    return;
                }
                if (this.awaitingDMMessage) {
                    const message = command.trim();
                    const recipient = this.tempDMRecipient;
                    this.awaitingDMMessage = false;
                    this.tempDMRecipient = '';
                    if (!recipient || !message) {
                        this.log('Recipient and message required.', 'error');
                        return;
                    }
                    this.logHtml('<span style="color:#99ccff">Message:</span> <span style="color:#fff">' + message + '</span>', 'info');
                    await this.sendDirectMessage(recipient, message);
                    this.log('✅ Email sent!', 'success');
                    return;
                }

                this.logCommand(command);
                // Hide faucet info box after first command
                try {
                    const infoBox = document.getElementById('faucetInfoBox');
                    if (infoBox && infoBox.style.display !== 'none') {
                        infoBox.style.display = 'none';
                    }
                } catch (e) {}
                const args = command.trim().split(/\s+/);
                const cmd = args[0].toLowerCase();

                if (cmd === 'email' && args[1] === 'clearkey') {
                    this.e2eePrivateKey = null;
                    this.log('E2EE private key cleared from memory.', 'success');
                        return;
                }

                // --- Handle awaiting input states before command parsing ---
                if (this.awaitingMixerDirectInput && args.length === 2) {
                    this.awaitingMixerDirectInput = false;
                    const privateKeyInput = args[0];
                    const amountStr = args[1];
                    try {
                        const mixerABI = [
                            "function deposit(bytes32 commitment) external payable"
                        ];
                        // Always use a JsonRpcProvider for direct private key flows
                        const OMEGA_RPC_URL = 'https://0x4e454228.rpc.aurora-cloud.dev';
                        const provider = new this.ethers.providers.JsonRpcProvider(OMEGA_RPC_URL);
                        const privateKey = privateKeyInput.startsWith('0x') ? privateKeyInput : '0x' + privateKeyInput;
                        const wallet = new this.ethers.Wallet(privateKey, provider);
                        // Debug: print wallet address
                        this.log(`Using wallet address: ${wallet.address}`, 'info');
                        // Debug: print provider network
                        const network = await provider.getNetwork();
                        this.log(`Provider network: ${network.name} (chainId: ${network.chainId})`, 'info');
                        // Debug: print wallet balance
                        const balance = await wallet.getBalance();
                        this.log(`Wallet balance: ${this.ethers.utils.formatEther(balance)} OMEGA`, 'info');
                        const mixerContract = new this.ethers.Contract('0xc57824b37a7fc769871075103c4dd807bfb3fd3e', mixerABI, wallet);
                        const depositAmount = this.ethers.utils.parseEther(amountStr);
                        const array = window.crypto.getRandomValues(new Uint8Array(32));
                        const secret = Array.from(array).map(b => b.toString(16).padStart(2, '0')).join('');
                        const commitment = this.ethers.utils.keccak256('0x' + secret);
                        this.logHtml(`1. Generated secret: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${secret}').then(() => window.terminal.log('✅ Secret copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy secret', 'error'))\">${secret}</span>`, 'info');
                        this.log(`2. Commitment: ${commitment}`, 'info');
                        this.log(`3. Deposit amount: ${amountStr} OMEGA`, 'info');
                        this.log('4. Creating wallet and calling contract...', 'info');
                        const tx = await mixerContract.deposit(commitment, { value: depositAmount });
                        this.log(`✅ Deposit transaction submitted! Hash: ${tx.hash}`, 'success');
                        this.log('Waiting for confirmation...', 'info');
                        try {
                            const receipt = await tx.wait();
                            this.log(`✅ Deposit confirmed! Block: ${receipt.blockNumber}`, 'success');
                            this.log('Your funds are now in the mixer. Use your secret to withdraw later.', 'info');
                        } catch (err) {
                            this.log('⚠️ Transaction was submitted but confirmation could not be detected in time.', 'warning');
                            this.log('You can check the status manually on the block explorer:', 'info');
                            this.logHtml(`<a href=\"https://0x4e454228.explorer.aurora-cloud.dev/tx/${tx.hash}\" target=\"_blank\">${tx.hash}</a>`, 'info');
                        }
                    } catch (error) {
                        this.log(`❌ Deposit failed: ${error.message}`, 'error');
                        this.log('Make sure you have enough OMEGA and a valid private key.', 'info');
                    }
                        return;
                    }
                if (this.awaitingMixerDirectAmount && args.length === 1) {
                    this.awaitingMixerDirectAmount = false;
                    const amountStr = args[0];
                    try {
                        // Mixer contract ABI (updated for new contract)
                        const mixerABI = [
                            "function deposit(bytes32 commitment) external payable"
                        ];
                        const privateKey = this.storedPrivateKey.startsWith('0x') ? this.storedPrivateKey : '0x' + this.storedPrivateKey;
                        const wallet = new this.ethers.Wallet(privateKey, this.provider);
                        const mixerContract = new this.ethers.Contract('0xc57824b37a7fc769871075103c4dd807bfb3fd3e', mixerABI, wallet);
                        const depositAmount = this.ethers.utils.parseEther(amountStr);
                        // Generate secret and commitment
                        const array = window.crypto.getRandomValues(new Uint8Array(32));
                        const secret = Array.from(array).map(b => b.toString(16).padStart(2, '0')).join('');
                        const commitment = this.ethers.utils.keccak256('0x' + secret);
                        this.logHtml(`1. Generated secret: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${secret}').then(() => window.terminal.log('✅ Secret copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy secret', 'error'))\">${secret}</span>`, 'info');
                        this.log(`2. Commitment: ${commitment}`, 'info');
                        this.log(`3. Deposit amount: ${amountStr} OMEGA`, 'info');
                        this.log('4. Creating wallet and calling contract...', 'info');
                        const tx = await mixerContract.deposit(commitment, { value: depositAmount });
                        this.log(`✅ Deposit transaction submitted! Hash: ${tx.hash}`, 'success');
                        this.log('Waiting for confirmation...', 'info');
                        try {
                            const receipt = await tx.wait();
                            this.log(`✅ Deposit confirmed! Block: ${receipt.blockNumber}`, 'success');
                            this.log('Your funds are now in the mixer. Use your secret to withdraw later.', 'info');
                        } catch (err) {
                            this.log('⚠️ Transaction was submitted but confirmation could not be detected in time.', 'warning');
                            this.log('You can check the status manually on the block explorer:', 'info');
                            this.logHtml(`<a href=\"https://0x4e454228.explorer.aurora-cloud.dev/tx/${tx.hash}\" target=\"_blank\">${tx.hash}</a>`, 'info');
                        }
                        // Clear stored private key
                        this.storedPrivateKey = null;
                    } catch (error) {
                        this.log(`❌ Deposit failed: ${error.message}`, 'error');
                        this.log('Make sure you have enough OMEGA and a valid private key.', 'info');
                        this.storedPrivateKey = null;
                    }
                    return;
                }
                if (this.awaitingPrivateKey && this.awaitingMixerWithdrawDirect && args.length === 1) {
                    // Withdraw-direct: received private key
                    this.awaitingPrivateKey = false;
                    this.awaitingMixerWithdrawDirect = false;
                    this.storedPrivateKey = args[0];
                    this.log('Now enter your secret and withdrawal address separated by a space:', 'info');
                    this.awaitingMixerWithdrawDirectParams = true;
                    return;
                }
                if (this.awaitingMixerWithdrawDirectParams && args.length === 2) {
                    // Withdraw-direct: received secret and address
                    this.awaitingMixerWithdrawDirectParams = false;
                    try {
                        this.log('=== Omega Mixer Withdraw (Direct) ===', 'info');
                        this.log('Withdrawing funds directly from contract...', 'info');
                        // Validate secret
                        let secretHex = args[0];
                        if (!secretHex.startsWith('0x')) secretHex = '0x' + secretHex;
                        if (secretHex.length !== 66) { // 2 for '0x' + 64 hex chars
                            this.log('❌ Secret must be 32 bytes (64 hex characters).', 'error');
                            this.storedPrivateKey = null;
                            return;
                        }
                        // Create wallet from private key (stored from previous step)
                        const privateKey = this.storedPrivateKey.startsWith('0x') ? this.storedPrivateKey : '0x' + this.storedPrivateKey;
                        const wallet = new this.ethers.Wallet(privateKey, this.provider);
                        // Mixer contract ABI
                        const mixerABI = [
                            "function withdraw(bytes32 secret, address to) external"
                        ];
                        const mixerContract = new this.ethers.Contract('0xc57824b37a7fc769871075103c4dd807bfb3fd3e', mixerABI, wallet);
                        const tx = await mixerContract.withdraw(secretHex, args[1]);
                        this.log(`✅ Withdrawal transaction submitted! Hash: ${tx.hash}`, 'success');
                        this.log('Waiting for confirmation...', 'info');
                        const receipt = await tx.wait();
                        this.log(`✅ Withdrawal confirmed! Block: ${receipt.blockNumber}`, 'success');
                        this.log(`✅ Funds withdrawn to: ${args[1]}`, 'success');
                        // Clear stored private key
                        this.storedPrivateKey = null;
                    } catch (error) {
                        this.log(`❌ Withdrawal failed: ${error.message}`, 'error');
                        this.log('Make sure you have a valid private key and the secret is correct.', 'info');
                        this.storedPrivateKey = null;
                    }
                    return;
                }
                // --- End awaiting input checks ---

                // --- Handle command parsing ---
                switch (cmd) {
                    case 'connect':
                        this.connectWallet();
                        break;
                    case 'disconnect':
                        this.disconnectWallet();
                        break;
                    case 'balance':
                        await this.showBalance();
                        break;
                    case 'theme':
                        this.setTheme(args[1]);
                        break;
                    case 'mine':
                        this.mine();
                        break;
                    case 'faucet':
                        if (args[1] === 'status') {
                            await this.showFaucetStatus();
                        } else {
                            this.faucetClaim();
                        }
                        break;
                    case 'status':
                        this.showStatus();
                        break;
                    case 'stats':
                        this.showStats();
                        break;
                    case 'send':
                        this.sendOmega(command);
                        break;
                    case 'clear':
                        this.clearTerminal();
                        break;
                    case 'help':
                        this.showHelp();
                        break;
                    case 'rickroll':
                        this.rickroll();
                        break;
                    case 'fortune':
                        this.fortune();
                        break;
                    case 'matrix':
                        this.matrix();
                        break;
                    case 'hack':
                        this.hack();
                        break;
                    case 'disco':
                        this.disco();
                        break;
                    case 'sudo':
                        this.sudoMine();
                        break;
                    case 'fund':
                        this.fundMiningWallet(args[1]);
                        break;
                    case 'stress':
                        this.startStressTest();
                        break;
                    case 'stopstress':
                        this.stopStressTest();
                        break;
                    case 'stressstats':
                        this.showStressStats();
                        break;
                    case 'mixer':
                        if (args[1] === '-help') {
                            this.log('=== Omega Mixer Help ===', 'info');
                            this.log('The Omega Mixer allows you to privately send OMEGA tokens by breaking the on-chain link between sender and receiver.', 'info');
                            this.log('How it works:', 'info');
                            this.log('1. Use "mixer deposit" to generate a secret and commitment, then manually call the contract.', 'info');
                            this.log('2. Use "mixer deposit-execute" to generate secret and call contract via MetaMask.', 'info');
                            this.log('3. Use "mixer deposit-direct" to generate secret and call contract directly (requires private key).', 'info');
                            this.log('4. Wait for the mixing round to complete (more users = more privacy).', 'info');
                            this.log('5. Use "mixer withdraw" to prepare your withdrawal. Enter your secret and the new address you want to receive funds at.', 'info');
                            this.log('6. In MetaMask (or via a relayer), call the withdraw function on the mixer contract with your secret and new address.', 'info');
                            this.log('7. For maximum privacy, use a relayer to submit the withdrawal transaction.', 'info');
                            this.log('NEVER share your secret. Anyone with the secret can withdraw your funds!', 'warning');
                            this.log('WARNING: Using deposit-direct requires entering your private key. Use at your own risk!', 'warning');
                        } else if (args[1] === 'deposit') {
                            // Generate secret and commitment
                            const array = window.crypto.getRandomValues(new Uint8Array(32));
                            const secret = Array.from(array).map(b => b.toString(16).padStart(2, '0')).join('');
                            const commitment = this.ethers.utils.keccak256('0x' + secret);
                            this.log('=== Omega Mixer Deposit ===', 'info');
                            this.logHtml(`1. Save this secret for withdrawal: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${secret}').then(() => window.terminal.log('✅ Secret copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy secret', 'error'))\">${secret}</span>`, 'info');
                            this.log(`2. Commitment (for deposit): ${commitment}`, 'info');
                            this.log(`3. In MetaMask, interact with the mixer contract:`, 'info');
                            this.logHtml(`   Contract: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('0xc57824b37a7fc769871075103c4dd807bfb3fd3e').then(() => window.terminal.log('✅ Address copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy address', 'error'))\">0xc57824b37a7fc769871075103c4dd807bfb3fd3e</span>`, 'info');
                            this.log(`   IMPORTANT: Do NOT send a plain transaction to this address!`, 'warning');
                            this.log(`   Instead, call the deposit function:`, 'info');
                            this.log(`   - Go to the contract in MetaMask`, 'info');
                            this.log(`   - Click "Write Contract"`, 'info');
                            this.log(`   - Find the "deposit" function`, 'info');
                            this.log(`   - Enter commitment: ${commitment}`, 'info');
                            this.log(`   - Set value to your desired OMEGA amount`, 'info');
                            this.log(`   - Submit the transaction`, 'info');
                            this.log('4. After mixing, use your secret to withdraw to a new address.', 'info');
                        } else if (args[1] === 'deposit-execute') {
                            // Generate secret and commitment, then prompt for amount
                            const array = window.crypto.getRandomValues(new Uint8Array(32));
                            const secret = Array.from(array).map(b => b.toString(16).padStart(2, '0')).join('');
                            const commitment = this.ethers.utils.keccak256('0x' + secret);
                            this.storedMixerSecret = secret;
                            this.storedMixerCommitment = commitment;
                            this.awaitingMixerExecuteAmount = true;
                            this.log('=== Omega Mixer Deposit (Auto-Execute) ===', 'info');
                            this.logHtml(`1. Generated secret: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${secret}').then(() => window.terminal.log('✅ Secret copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy secret', 'error'))\">${secret}</span>`, 'info');
                            this.log(`2. Commitment: ${commitment}`, 'info');
                            this.log('3. Enter deposit amount in OMEGA (e.g. 0.1):', 'info');
                            return;
                        }
                        // Add handler for awaitingMixerExecuteAmount
                        if (this.awaitingMixerExecuteAmount && args.length === 1) {
                            this.awaitingMixerExecuteAmount = false;
                            const amountStr = args[0];
                            try {
                                const mixerABI = [
                                    "function deposit(bytes32 commitment) external payable"
                                ];
                                const mixerContract = new this.ethers.Contract('0xc57824b37a7fc769871075103c4dd807bfb3fd3e', mixerABI, this.provider.getSigner());
                                const depositAmount = this.ethers.utils.parseEther(amountStr);
                                const commitment = this.storedMixerCommitment;
                                const tx = await mixerContract.deposit(commitment, { value: depositAmount });
                                this.log(`✅ Deposit transaction submitted! Hash: ${tx.hash}`, 'success');
                                this.log('Waiting for confirmation...', 'info');
                                try {
                                    const receipt = await tx.wait();
                                    this.log(`✅ Deposit confirmed! Block: ${receipt.blockNumber}`, 'success');
                                    this.log('Your funds are now in the mixer. Use your secret to withdraw later.', 'info');
                                } catch (err) {
                                    this.log('⚠️ Transaction was submitted but confirmation could not be detected in time.', 'warning');
                                    this.log('You can check the status manually on the block explorer:', 'info');
                                    this.logHtml(`<a href=\"https://0x4e454228.explorer.aurora-cloud.dev/tx/${tx.hash}\" target=\"_blank\">${tx.hash}</a>`, 'info');
                                }
                                // Clear stored secret/commitment
                                this.storedMixerSecret = null;
                                this.storedMixerCommitment = null;
                            } catch (error) {
                                this.log(`❌ Deposit failed: ${error.message}`, 'error');
                                this.log('Make sure you have enough OMEGA in your wallet.', 'info');
                                this.storedMixerSecret = null;
                                this.storedMixerCommitment = null;
                            }
                            return;
                        }
                        else if (args[1] === 'deposit-direct') {
                            this.log('=== Omega Mixer Deposit (Direct) ===', 'warning');
                            this.log('WARNING: This will require your private key. Use at your own risk!', 'warning');
                            this.log('Enter your private key and deposit amount separated by a space (e.g. <privatekey> 0.1):', 'info');
                            this.awaitingMixerDirectInput = true;
                            return;
                        } else if (args[1] === 'withdraw') {
                            this.log('=== Omega Mixer Withdraw ===', 'info');
                            this.log('Enter your secret (hex) and withdrawal address separated by a space:', 'info');
                            this.awaitingMixerWithdraw = true;
                        } else if (this.awaitingMixerWithdraw && args.length === 3) {
                            // args[1] = secret, args[2] = to_address
                            this.awaitingMixerWithdraw = false;
                            this.log('=== Omega Mixer Withdraw ===', 'info');
                            this.log('In MetaMask (or via relayer), call the withdraw function on the mixer contract:', 'info');
                            this.logHtml('   Contract: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText(\'0xc57824b37a7fc769871075103c4dd807bfb3fd3e\').then(() => window.terminal.log(\'✅ Address copied to clipboard!\', \'success\')).catch(() => window.terminal.log(\'❌ Failed to copy address\', \'error\'))\">0xc57824b37a7fc769871075103c4dd807bfb3fd3e</span>', 'info');
                            this.log('   Function: withdraw(bytes32 secret, address to)', 'info');
                            this.log(`   Secret: ${args[1]}`, 'info');
                            this.log(`   To: ${args[2]}`, 'info');
                            this.log('You can use a relayer to submit this transaction for extra privacy.', 'info');
                        } else if (args[1] === 'withdraw-direct') {
                            this.log('=== Omega Mixer Withdraw (Direct) ===', 'warning');
                            this.log('WARNING: This will require your private key. Use at your own risk!', 'warning');
                            this.log('Enter your private key (without 0x prefix):', 'info');
                            this.awaitingPrivateKey = true;
                            this.awaitingMixerWithdrawDirect = true;
                        } else {
                            this.log('Usage: mixer deposit | mixer deposit-execute | mixer deposit-direct | mixer withdraw | mixer withdraw-direct | mixer -help', 'info');
                        }
                        break;
                    case 'claim':
                        await this.claim();
                        break;
                    case 'stop':
                        this.stopAll();
                        break;
                    case 'ens':
                        if (!args[1]) {
                            this.log('Usage: ens register <name> | ens resolve <name>', 'info');
                        break;
                        }
                        if (args[1] === 'register' && args[2]) {
                            if (!this.signer) {
                                this.log('Please connect your wallet first using: connect', 'error');
                        break;
                            }
                            const name = args[2];
                            this.log(`Registering ENS name: ${name}...`, 'info');
                            try {
                                const ens = this.getENSContract(this.signer);
                                const tx = await ens.register(name);
                                this.log(`✅ Registration transaction sent: ${tx.hash}`, 'success');
                                this.log('Waiting for confirmation...', 'info');
                                await tx.wait();
                                this.log(`✅ Name registered: ${name}`, 'success');
                            } catch (err) {
                                this.log(`❌ Registration failed: ${err.message}`, 'error');
                            }
                        break;
                        } else if (args[1] === 'resolve' && args[2]) {
                            const name = args[2];
                            this.log(`Resolving ENS name: ${name}...`, 'info');
                            try {
                                const ens = this.getENSContract();
                                const address = await ens.resolve(name);
                                if (address && address !== '0x0000000000000000000000000000000000000000') {
                                    this.logHtml(`✅ <b>${name}</b> resolves to <span class="copyable" onclick="navigator.clipboard.writeText('${address}').then(() => window.terminal.log('✅ Address copied!', 'success'))">${address}</span>`, 'success');
                                } else {
                                    this.log(`❌ Name not found: ${name}`, 'error');
                                }
                            } catch (err) {
                                this.log(`❌ Resolve failed: ${err.message}`, 'error');
                            }
                        break;
                        } else if (args[1] === 'search' && args[2]) {
                            const name = args[2];
                            this.log(`Searching for ENS name: ${name}...`, 'info');
                            try {
                                const ens = this.getENSContract();
                                const address = await ens.resolve(name);
                                if (address && address !== '0x0000000000000000000000000000000000000000') {
                                    this.logHtml(`✅ <b>${name}</b> is owned by <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${address}').then(() => window.terminal.log('✅ Address copied!', 'success'))\">${address}</span>`, 'success');
                                } else {
                                    this.log(`❌ Name not found: ${name}`, 'error');
                                }
                            } catch (err) {
                                this.log(`❌ ENS search failed: ${err.message}`, 'error');
                            }
                        break;
                        } else {
                            this.log('Usage: ens register <name> | ens resolve <name>', 'info');
                        }
                        break;
                    case 'dm':
                        if (!args[1]) {
                            this.log('Usage: dm <recipient> <message>', 'info');
                        break;
                        }
                        if (args.length < 3) {
                            this.log('Usage: dm <recipient> <message>', 'info');
                        break;
                        }
                        const recipient = args[1];
                        const dmMessage = args.slice(2).join(' ');
                        await this.sendDirectMessage(recipient, dmMessage);
                        break;
                    case 'inbox':
                    case 'messages':
                        await this.showInbox();
                        break;
                    case 'email':
                        this.awaitingDMRecipient = true;
                        this.awaitingDMMessage = false;
                        this.tempDMRecipient = '';
                        this.log('Enter recipient (address or ENS):', 'info');
                        break;
                    case 'dexscreener':
                        await this.handleDexScreenerCommand(args);
                        break;
                    case 'geckoterminal':
                        await this.handleGeckoTerminalCommand(args);
                        break;
                    case 'stock':
                        await this.handleStockCommand(args);
                        break;
                    case 'alphakey':
                        await this.handleAlphaKeyCommand(args);
                        break;
                    case 'ds':
                        await this.handleDexScreenerAlias(args);
                        break;
                    case 'cg':
                        await this.handleGeckoTerminalAlias(args);
                        break;
                    case 'alpha':
                        await this.handleAlphaAlias(args);
                        break;
                    case 'create':
                        await this.handleCreateCommand(args);
                        break;
                    default:
                        if (cmd) {
                            this.log(`Command not found: ${command}`, 'error');
                            this.log('Type "help" for available commands', 'info');
                        }
                }
                // --- End command parsing ---
            }

            async handleDexScreenerCommand(args) {
                if (!args[1]) {
                    this.log('Usage: dexscreener <search|trending|pair> [query]', 'info');
                    return;
                }
                const sub = args[1];
                if (sub === 'search' && args[2]) {
                    const q = args.slice(2).join(' ');
                    this.log(`Searching DexScreener for: ${q}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/dex/search?q=${encodeURIComponent(q)}`);
                        const data = await res.json();
                        if (Array.isArray(data) && data.length > 0) {
                            data.forEach((item, idx) => {
                                this.logHtml(`<b>${idx + 1}. ${item.symbol || ''} (${item.chainId || ''})</b>`, 'output');
                                this.logHtml(`Name: <b>${item.name || ''}</b>`, 'output');
                                this.logHtml(`Price: <b>${item.priceUsd || item.price || 'N/A'}</b>`, 'output');
                                this.logHtml(`Token Address: <span class='copyable' onclick="navigator.clipboard.writeText('${item.tokenAddress || ''}')">${item.tokenAddress || ''}</span>`, 'output');
                                if (item.url) this.logHtml(`<a href="${item.url}" target="_blank">View on DexScreener</a>`, 'output');
                                this.logHtml('<hr>', 'output');
                            });
                        } else if (data.pairs && Array.isArray(data.pairs)) {
                            data.pairs.forEach((pair, idx) => {
                                this.logHtml(`<b>${idx + 1}. ${pair.baseToken?.symbol || ''} (${pair.chainId || ''})</b>`, 'output');
                                this.logHtml(`Name: <b>${pair.baseToken?.name || ''}</b>`, 'output');
                                this.logHtml(`Price: <b>${pair.priceUsd || pair.price || 'N/A'}</b>`, 'output');
                                this.logHtml(`Token Address: <span class='copyable' onclick="navigator.clipboard.writeText('${pair.baseToken?.address || ''}')">${pair.baseToken?.address || ''}</span>`, 'output');
                                if (pair.url) this.logHtml(`<a href="${pair.url}" target="_blank">View on DexScreener</a>`, 'output');
                                this.logHtml('<hr>', 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No results found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('DexScreener search failed: ' + e.message, 'error');
                    }
                } else if (sub === 'trending') {
                    this.log('Fetching DexScreener trending tokens...', 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/dex/trending`);
                        const data = await res.json();
                        if (Array.isArray(data) && data.length > 0) {
                            data.forEach((item, idx) => {
                                this.logHtml(`<b>${idx + 1}. ${item.symbol || ''} (${item.chainId || ''})</b>`, 'output');
                                this.logHtml(`Name: <b>${item.name || ''}</b>`, 'output');
                                this.logHtml(`Price: <b>${item.priceUsd || item.price || 'N/A'}</b>`, 'output');
                                this.logHtml(`Token Address: <span class='copyable' onclick="navigator.clipboard.writeText('${item.tokenAddress || ''}')">${item.tokenAddress || ''}</span>`, 'output');
                                if (item.url) this.logHtml(`<a href="${item.url}" target="_blank">View on DexScreener</a>`, 'output');
                                this.logHtml('<hr>', 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No trending tokens found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('DexScreener trending failed: ' + e.message, 'error');
                    }
                } else {
                    this.log('Usage: dexscreener <search|trending|pair> [query]', 'info');
                }
            }

            async handleGeckoTerminalCommand(args) {
                if (!args[1]) {
                    this.log('Usage: geckoterminal <search|trending|token> [network] [query]', 'info');
                    return;
                }
                // Define show404Suggestion at the top so it is always in scope
                const show404Suggestion = (data) => {
                    if (data && data.errors && Array.isArray(data.errors)) {
                        const is404 = data.errors.some(e => e.status === '404' || e.title === 'Not Found');
                        if (is404) {
                            this.logHtml('<span style="color:#ff3333">Not Found. Try <b>cg networks</b> to see available networks and use the correct slug.</span>', 'error');
                        }
                    }
                };
                const sub = args[1];
                if (sub === 'search' && args[2]) {
                    const q = args.slice(2).join(' ');
                    this.log(`Searching GeckoTerminal for: ${q}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/search?q=${encodeURIComponent(q)}`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            data.data.forEach((item, idx) => {
                                const pair = item.attributes;
                                this.logHtml(`<b>${idx + 1}. ${pair.name || ''}</b>`, 'output');
                                this.logHtml(`DEX: <b>${pair.dex_name || ''}</b> | Network: <b>${pair.network || ''}</b>`, 'output');
                                this.logHtml(`Base: <b>${pair.base_token_symbol || ''}</b> | Quote: <b>${pair.quote_token_symbol || ''}</b>`, 'output');
                                this.logHtml(`Price: <b>${pair.price_usd || 'N/A'}</b> | Volume 24h: <b>${pair.volume_usd_24h || 'N/A'}</b>`, 'output');
                                if (pair.gecko_terminal_url) this.logHtml(`<a href="${pair.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`, 'output');
                                this.logHtml('<hr>', 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No results found.</span>', 'error');
                            this.logHtml('<span style="color:#cccccc">Tip: GeckoTerminal search only returns results for exact or popular pair names.</span>', 'info');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal search failed: ' + e.message, 'error');
                    }
                } else if (sub === 'trending' && args[2]) {
                    const network = args[2];
                    this.log(`Fetching GeckoTerminal trending tokens for network: ${network}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/trending`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            data.data.forEach((item, idx) => {
                                const pair = item.attributes;
                                this.logHtml(`<b>${idx + 1}. ${pair.name || ''}</b>`, 'output');
                                this.logHtml(`DEX: <b>${pair.dex_name || ''}</b> | Network: <b>${pair.network || ''}</b>`, 'output');
                                this.logHtml(`Base: <b>${pair.base_token_symbol || ''}</b> | Quote: <b>${pair.quote_token_symbol || ''}</b>`, 'output');
                                this.logHtml(`Price: <b>${pair.price_usd || 'N/A'}</b> | Volume 24h: <b>${pair.volume_usd_24h || 'N/A'}</b>`, 'output');
                                if (pair.gecko_terminal_url) this.logHtml(`<a href="${pair.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`, 'output');
                                this.logHtml('<hr>', 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No trending tokens found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal trending failed: ' + e.message, 'error');
                    }
                } else if (sub === 'networks') {
                    this.log('Fetching GeckoTerminal networks...', 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml('<b>Available Networks:</b>', 'output');
                            data.data.forEach((item) => {
                                const net = item.attributes;
                                const id = item.id;
                                const cg = net.coingecko_asset_platform_id ? ` | Coingecko: <b>${net.coingecko_asset_platform_id}</b>` : '';
                                this.logHtml(`<b>${net.name}</b> (<span style='color:#99ccff'>${id}</span>)${cg}`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No networks found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('GeckoTerminal networks fetch failed: ' + e.message, 'error');
                    }
                } else if (sub === 'dexes' && args[2]) {
                    const network = args[2];
                    this.log(`Fetching GeckoTerminal dexes for network: ${network}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/dexes`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml(`<b>DEXes for ${network}:</b>`, 'output');
                            data.data.forEach((item) => {
                                const dex = item.attributes;
                                const id = item.id;
                                this.logHtml(`<b>${dex.name}</b> (<span style='color:#99ccff'>${id}</span>)`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No DEXes found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal dexes fetch failed: ' + e.message, 'error');
                    }
                } else if (sub === 'pools' && args[2]) {
                    const network = args[2];
                    this.log(`Fetching GeckoTerminal pools for network: ${network}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/pools`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml(`<b>Pools for ${network}:</b>`, 'output');
                            data.data.forEach((item) => {
                                const pool = item.attributes;
                                this.logHtml(`<b>${pool.name}</b> | DEX: <b>${pool.dex_name}</b> | TVL: <b>${pool.tvl_usd || 'N/A'}</b>`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No pools found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal pools fetch failed: ' + e.message, 'error');
                    }
                } else if (sub === 'token' && args[2] && args[3]) {
                    const network = args[2];
                    const address = args[3];
                    this.log(`Fetching GeckoTerminal token info for network: ${network}, address: ${address}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/tokens/${address}`);
                        const data = await res.json();
                        if (data && data.data && data.data.attributes) {
                            const token = data.data.attributes;
                            this.logHtml(`<b>${token.name} (${token.symbol})</b>`, 'output');
                            this.logHtml(`Price: <b>${token.price_usd || 'N/A'}</b> | TVL: <b>${token.tvl_usd || 'N/A'}</b>`, 'output');
                            this.logHtml(`DEX Count: <b>${token.dex_count || 'N/A'}</b> | Pool Count: <b>${token.pool_count || 'N/A'}</b>`, 'output');
                            if (token.gecko_terminal_url) this.logHtml(`<a href="${token.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`, 'output');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No token info found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal token fetch failed: ' + e.message, 'error');
                    }
                } else if (sub === 'tokenpools' && args[2] && args[3]) {
                    const network = args[2];
                    const tokenAddress = args[3];
                    this.log(`Fetching GeckoTerminal pools for token: ${tokenAddress} on network: ${network}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/tokens/${tokenAddress}/pools`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml(`<b>Pools for token ${tokenAddress} on ${network}:</b>`, 'output');
                            data.data.forEach((item) => {
                                const pool = item.attributes;
                                this.logHtml(`<b>${pool.name}</b> | DEX: <b>${pool.dex_name}</b> | TVL: <b>${pool.tvl_usd || 'N/A'}</b>`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No pools found for this token.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal tokenpools fetch failed: ' + e.message, 'error');
                    }
                } else if (sub === 'poolinfo' && args[2] && args[3]) {
                    const network = args[2];
                    const poolAddress = args[3];
                    this.log(`Fetching GeckoTerminal pool info for network: ${network}, pool: ${poolAddress}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/info`);
                        const data = await res.json();
                        if (data && data.data && data.data.attributes) {
                            const pool = data.data.attributes;
                            this.logHtml(`<b>${pool.name}</b> | DEX: <b>${pool.dex_name}</b> | TVL: <b>${pool.tvl_usd || 'N/A'}</b>`, 'output');
                            this.logHtml(`Base: <b>${pool.base_token_symbol}</b> | Quote: <b>${pool.quote_token_symbol}</b>`, 'output');
                            this.logHtml(`Price: <b>${pool.price_usd || 'N/A'}</b> | Volume 24h: <b>${pool.volume_usd_24h || 'N/A'}</b>`, 'output');
                            if (pool.gecko_terminal_url) this.logHtml(`<a href="${pool.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`, 'output');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No pool info found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal poolinfo fetch failed: ' + e.message, 'error');
                    }
                } else if (sub === 'ohlcv' && args[2] && args[3] && args[4]) {
                    const network = args[2];
                    const poolAddress = args[3];
                    const timeframe = args[4];
                    this.log(`Fetching GeckoTerminal OHLCV for network: ${network}, pool: ${poolAddress}, timeframe: ${timeframe}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/ohlcv/${timeframe}`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml(`<b>OHLCV (${timeframe}) for pool ${poolAddress}:</b>`, 'output');
                            data.data.forEach((item) => {
                                this.logHtml(`<b>${item.timestamp}</b>: O: <b>${item.open}</b>, H: <b>${item.high}</b>, L: <b>${item.low}</b>, C: <b>${item.close}</b>, V: <b>${item.volume}</b>`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No OHLCV data found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal ohlcv fetch failed: ' + e.message, 'error');
                    }
                } else if (sub === 'trades' && args[2] && args[3]) {
                    const network = args[2];
                    const poolAddress = args[3];
                    this.log(`Fetching GeckoTerminal trades for network: ${network}, pool: ${poolAddress}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/trades`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml(`<b>Recent trades for pool ${poolAddress}:</b>`, 'output');
                            data.data.slice(0, 10).forEach((item) => {
                                const trade = item.attributes;
                                this.logHtml(`<b>${trade.timestamp}</b>: <b>${trade.amount_usd || 'N/A'} USD</b> | Type: <b>${trade.trade_type}</b> | Price: <b>${trade.price_usd || 'N/A'}</b>`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No trades found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal trades fetch failed: ' + e.message, 'error');
                    }
                } else {
                    this.log('Usage: geckoterminal <search|trending|token> [network] [query]', 'info');
                }
            }

            async handleStockCommand(args) {
                if (!args[1]) {
                    this.log('Usage: stock <quote|search|daily|overview|inflation|cpi|gdp> [symbol]', 'info');
                    return;
                }
                const sub = args[1];
                if (sub === 'quote' && args[2]) {
                    const symbol = args[2];
                    this.log(`Fetching stock quote for: ${symbol}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/stock/quote/${encodeURIComponent(symbol)}`);
                        const data = await res.json();
                        if (data && data.price) {
                            this.logHtml(`<b>${symbol} Stock Quote</b>`, 'output');
                            this.logHtml(`Price: <b>${data.price}</b>`, 'output');
                            this.logHtml(`Change: <b>${data.change}</b> (${data.changePercent})`, 'output');
                            this.logHtml(`Open: <b>${data["02. open"] || ''}</b> | High: <b>${data["03. high"] || ''}</b> | Low: <b>${data["04. low"] || ''}</b>`, 'output');
                            this.logHtml(`Volume: <b>${data["06. volume"] || ''}</b> | Previous Close: <b>${data["08. previous close"] || ''}</b>`, 'output');
                            this.logHtml(`Latest Trading Day: <b>${data["07. latest trading day"] || ''}</b>`, 'output');
                        } else if (data && data.error) {
                            this.logHtml(`<span style='color:#ff3333'>${data.error}</span>`, 'error');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No quote found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('Stock quote failed: ' + e.message, 'error');
                    }
                } else if (sub === 'search' && args[2]) {
                    const q = args.slice(2).join(' ');
                    this.log(`Searching stocks for: ${q}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/stock/search?q=${encodeURIComponent(q)}`);
                        const data = await res.json();
                        if (data && data.bestMatches && Array.isArray(data.bestMatches) && data.bestMatches.length > 0) {
                            data.bestMatches.forEach((match, idx) => {
                                this.logHtml(`<b>${idx + 1}. ${match['2. name']} (${match['1. symbol']})</b>`, 'output');
                                this.logHtml(`Type: <b>${match['3. type']}</b> | Region: <b>${match['4. region']}</b>`, 'output');
                                this.logHtml(`Currency: <b>${match['8. currency']}</b> | Match Score: <b>${match['9. matchScore']}</b>`, 'output');
                                this.logHtml('<hr>', 'output');
                            });
                        } else if (data && data.error) {
                            this.logHtml(`<span style='color:#ff3333'>${data.error}</span>`, 'error');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No results found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('Stock search failed: ' + e.message, 'error');
                    }
                } else if (sub === 'daily' && args[2]) {
                    const symbol = args[2];
                    this.log(`Fetching daily stock data for: ${symbol}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/stock/daily/${encodeURIComponent(symbol)}`);
                        const data = await res.json();
                        if (data && data['Time Series (Daily)']) {
                            const series = data['Time Series (Daily)'];
                            const dates = Object.keys(series).slice(0, 5); // Show last 5 days
                            this.logHtml(`<b>${symbol} - Last 5 Days</b>`, 'output');
                            dates.forEach(date => {
                                const d = series[date];
                                this.logHtml(`<b>${date}</b>: Open: <b>${d['1. open']}</b>, High: <b>${d['2. high']}</b>, Low: <b>${d['3. low']}</b>, Close: <b>${d['4. close']}</b>, Volume: <b>${d['5. volume']}</b>`, 'output');
                            });
                        } else if (data && data.error) {
                            this.logHtml(`<span style='color:#ff3333'>${data.error}</span>`, 'error');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No daily data found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('Stock daily failed: ' + e.message, 'error');
                    }
                } else if (sub === 'overview' && args[2]) {
                    const symbol = args[2];
                    this.log(`Fetching stock overview for: ${symbol}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/stock/overview/${encodeURIComponent(symbol)}`);
                        const data = await res.json();
                        if (data && data.Symbol) {
                            this.logHtml(`<b>${data.Name} (${data.Symbol})</b>`, 'output');
                            this.logHtml(`Sector: <b>${data.Sector}</b> | Industry: <b>${data.Industry}</b>`, 'output');
                            this.logHtml(`Market Cap: <b>${data.MarketCapitalization}</b> | EPS: <b>${data.EPS}</b>`, 'output');
                            this.logHtml(`PE Ratio: <b>${data.PERatio}</b> | Dividend Yield: <b>${data.DividendYield}</b>`, 'output');
                            this.logHtml(`Description: <span style='color:#cccccc'>${data.Description}</span>`, 'output');
                        } else if (data && data.error) {
                            this.logHtml(`<span style='color:#ff3333'>${data.error}</span>`, 'error');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No overview found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('Stock overview failed: ' + e.message, 'error');
                    }
                } else if (sub === 'inflation') {
                    this.log('Fetching US inflation data...', 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/stock/inflation`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data)) {
                            this.logHtml('<b>US Inflation (last 5 years):</b>', 'output');
                            data.data.slice(-5).forEach((item) => {
                                this.logHtml(`<b>${item.date}</b>: <b>${item.value}</b>`, 'output');
                            });
                        } else if (data && data.error) {
                            this.logHtml(`<span style='color:#ff3333'>${data.error}</span>`, 'error');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No inflation data found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('Inflation fetch failed: ' + e.message, 'error');
                    }
                } else if (sub === 'cpi') {
                    this.log('Fetching US CPI data...', 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/stock/cpi`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data)) {
                            this.logHtml('<b>US CPI (last 5 years):</b>', 'output');
                            data.data.slice(-5).forEach((item) => {
                                this.logHtml(`<b>${item.date}</b>: <b>${item.value}</b>`, 'output');
                            });
                        } else if (data && data.error) {
                            this.logHtml(`<span style='color:#ff3333'>${data.error}</span>`, 'error');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No CPI data found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('CPI fetch failed: ' + e.message, 'error');
                    }
                } else if (sub === 'gdp') {
                    this.log('Fetching US GDP data...', 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/stock/gdp`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data)) {
                            this.logHtml('<b>US Real GDP (last 5 years):</b>', 'output');
                            data.data.slice(-5).forEach((item) => {
                                this.logHtml(`<b>${item.date}</b>: <b>${item.value}</b>`, 'output');
                            });
                        } else if (data && data.error) {
                            this.logHtml(`<span style='color:#ff3333'>${data.error}</span>`, 'error');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No GDP data found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('GDP fetch failed: ' + e.message, 'error');
                    }
                } else {
                    this.log('Usage: stock <quote|search|daily|overview|inflation|cpi|gdp> [symbol]', 'info');
                }
            }

            async handleAlphaKeyCommand(args) {
                this.log('Alpha Vantage API key is managed by the relayer. No action needed.', 'info');
            }

            async showUnifiedHelp() {
                this.logHtml('<span style="color:#33bbff">=== Omega Terminal Commands ===</span>', 'info');
                this.log('--- Wallet ----', 'output');
                this.logHtml('<span style="color:#33bbff">Commands: connect | disconnect | balance | faucet</span>', 'info');
                this.log('--- Mining ---', 'output');
                this.logHtml('<span style="color:#33bbff">Commands: mine | claim | status | stats</span>', 'info');
                this.log('--- ENS / Domains ----', 'output');
                this.logHtml('<span style="color:#33bbff">Commands: send | ens register | ens resolve | ens search</span>', 'info');
                this.log('--- Mixer (Privacy) ----', 'output');
                this.logHtml('<span style="color:#33bbff">Commands: mixer deposit | mixer deposit-execute | mixer deposit-direct | mixer withdraw | mixer withdraw-direct | mixer -help</span>', 'info');
                this.log('--- Stress Test ----', 'output');
                this.logHtml('<span style="color:#33bbff">Commands: stress | stopstress | stressstats</span>', 'info');
                this.log('--- Fun & Misc ----', 'output');
                this.logHtml('<span style="color:#33bbff">Commands: theme | clear | help | rickroll | fortune | matrix | hack | disco | sudo mine | clob | v2 | stop</span>', 'info');
                this.log('--- On Chain Email ----', 'output');
                this.logHtml('<span style="color:#33bbff">Commands: email | inbox</span>', 'info');
                this.log('--- web3 ---', 'output');
                this.logHtml('<table style="width:100%;border:none;"><tr>' +
                  '<td style="vertical-align:top;width:33%;padding-right:16px;">' +
                  '<span style="color:#33bbff">Dexscreener:</span><br>' +
                  '<span style="color:#99ccff">commands: ds help</span>' +
                  '</td>' +
                  '<td style="vertical-align:top;width:33%;padding-right:16px;">' +
                  '<span style="color:#33bbff">GeckoTerminal:</span><br>' +
                  '<span style="color:#99ccff">commands: cg help</span>' +
                  '</td>' +
                  '<td style="vertical-align:top;width:33%;">' +
                  '<span style="color:#33bbff">Token Creator:</span><br>' +
                  '<span style="color:#99ccff">command: create</span>' +
                  '</td>' +
                  '</tr></table>', 'output');
                this.log('--- stocks & economy ---', 'output');
                this.logHtml('<span style="color:#33bbff">alpha</span>', 'info');
                this.logHtml('<span style="color:#99ccff">commands: alpha help</span>', 'output');
                this.log('---', 'output');
            }

            async mine() {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }

                if (!this.contract) {
                    this.log('Mining contract not connected. Please check your connection.', 'error');
                    return;
                }

                if (this.isMining) {
                    this.log('Mining is already in progress. Use "stop" to stop mining.', 'error');
                    return;
                }

                // Generate a new mining wallet (if not already generated)
                if (!this.miningWallet) {
                    this.miningWallet = this.ethers.Wallet.createRandom();
                    this.log('Fund Omega Rig For Mining', 'info');
                    this.logHtml(`Address: <span class="copyable" onclick="navigator.clipboard.writeText('${this.miningWallet.address}').then(() => window.terminal.log('✅ Address copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy address', 'error'))">${this.miningWallet.address}</span>`, 'output');
                    this.miningWallet = this.miningWallet.connect(this.provider);
                }

                this.isMining = true;
                this.mineCount = 0;
                this.totalEarned = 0;
                this.startTime = Date.now();
                this.ghostTransactionCount = 0;

                this.log('🚀 Welcome To Omega Terminal v1.1.1!', 'success');
                this.log('⛏️  Automated Mining Mode Activated! Mining wallet will send all transactions.', 'info');
                this.log('💰 Average Reward: 0.0001 OMEGA | Max Reward: 1.0 OMEGA', 'info');
                this.logHtml('Waiting for mining wallet to be funded with OMEGA for gas...<br>💡 You need to fund your mining wallet with at least 0.002 OMEGA <span class="fund-link" style="color:#00ff99;cursor:pointer;text-decoration:underline;" onclick="window.terminal.fundMiningWallet(\'0.002\')">[Click here to fund]</span>', 'info');

                // Wait for funding before starting mining
                const minGas = this.ethers.utils.parseEther('0.002'); // Lowered for easier testing
                const checkAndStartMining = async () => {
                    if (!this.isMining) return;
                    const balance = await this.provider.getBalance(this.miningWallet.address);
                    if (balance.gte(minGas)) {
                        this.log('✅ Mining wallet funded! Starting mining...', 'success');
                        this.log('⛏️  Entering mining loop...', 'info'); // Added debug log
                        // Fetch and store the starting nonce
                        this.miningNonce = await this.provider.getTransactionCount(this.miningWallet.address, 'latest');
                        this.startAutomatedMiningLoop();
                    } else {
                        setTimeout(checkAndStartMining, 5000);
                    }
                };
                checkAndStartMining();
            }
            
            async startAutomatedMiningLoop() {
                const mineNextBlock = async () => {
                    if (!this.isMining) return;

                    try {
                        this.mineCount++;
                        const nonce = this.miningNonce;
                        this.miningNonce++;
                        const solution = this.generateRandomSolution();
                        this.log(`⛏️  Mining block #${this.mineCount}...`, 'info');
                        this.log(`🎯 Nonce: ${nonce}`, 'output');
                        // --- Begin hashing animation ---
                        const spinnerFrames = ['|', '/', '-', '\\'];
                        let spinnerIndex = 0;
                        for (let i = 0; i < 10; i++) {
                            await new Promise(resolve => setTimeout(resolve, 80));
                            this.log(`🔒 [${spinnerFrames[spinnerIndex]}] Hashing: ${this.generateFakeHash()}`, 'output');
                            spinnerIndex = (spinnerIndex + 1) % spinnerFrames.length;
                        }
                        // --- End hashing animation ---
                        this.log(`🔑 Solution: ${solution.slice(0, 16)}...`, 'output');
                        const tx = await this.contract.connect(this.miningWallet).mineBlock(nonce, solution, {
                            gasLimit: 200000,
                            gasPrice: await this.provider.getGasPrice()
                        });
                        this.logHtml(`📤 Transaction sent: <span class="copyable" onclick="navigator.clipboard.writeText('${tx.hash}').then(() => window.terminal.log('✅ Transaction hash copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy transaction hash', 'error'))">${tx.hash}</span>`, 'info');
                        const receipt = await tx.wait();
                        if (receipt.status === 1) {
                            try {
                                const minerInfo = await this.contract.getMinerInfo(this.miningWallet.address);
                                const pendingRewards = minerInfo[2];
                                const rewardInWei = pendingRewards;
                                const rewardInEther = this.ethers.utils.formatEther(rewardInWei);
                                if (rewardInWei.gt(0)) {
                                    this.totalEarned += parseFloat(rewardInEther);
                                    this.log(`💰 Mining reward: +${rewardInEther} OMEGA`, 'success');
                                    this.log(`💳 Total earned this session: ${this.totalEarned.toFixed(6)} OMEGA`, 'info');
                                } else {
                                    this.log(`⛏️  Block mined (no reward this time)`, 'output');
                                }
                            } catch (error) {
                                this.log(`⚠️ Could not fetch reward info: ${error.message}`, 'warning');
                                const simulatedReward = this.calculateMiningReward();
                                if (simulatedReward > 0) {
                                    this.totalEarned += simulatedReward;
                                    this.log(`💰 Mining reward: +${simulatedReward.toFixed(6)} OMEGA (simulated)`, 'success');
                                    this.log(`💳 Total earned this session: ${this.totalEarned.toFixed(6)} OMEGA`, 'info');
                                } else {
                                    this.log(`⛏️  Block mined (no reward this time)`, 'output');
                                }
                            }
                        } else {
                            this.log(`❌ Mining transaction failed`, 'error');
                        }
                    } catch (error) {
                        this.log(`❌ Mining failed: ${error.message}`, 'error');
                        if (error.message && (error.message.includes('nonce') || error.message.includes('replacement'))) {
                            this.log('🔄 Nonce error detected, re-syncing nonce from network...', 'warning');
                            this.miningNonce = await this.provider.getTransactionCount(this.miningWallet.address, 'latest');
                        }
                    }
                    if (this.isMining) setTimeout(mineNextBlock, 15000);
                };
                mineNextBlock();
            }
            
            generateRandomSolution() {
                const chars = '0123456789abcdef';
                let solution = '0x';
                for (let i = 0; i < 64; i++) {
                    solution += chars[Math.floor(Math.random() * chars.length)];
                }
                return solution;
            }
            
            calculateMiningReward() {
                const random = Math.random();
                
                // 0.1% chance for max reward (1.0 OMEGA)
                if (random < 0.001) {
                    return 1.0;
                }
                // 1% chance for medium reward (0.01 OMEGA)
                else if (random < 0.01) {
                    return 0.01;
                }
                // 10% chance for small reward (0.001 OMEGA)
                else if (random < 0.1) {
                    return 0.001;
                }
                // 30% chance for tiny reward (0.0001 OMEGA)
                else if (random < 0.3) {
                    return 0.0001;
                }
                // 60% chance for no reward
                else {
                    return 0;
                }
            }
            
            generateFakeHash() {
                const chars = '0123456789abcdef';
                let hash = '0x';
                for (let i = 0; i < 64; i++) {
                    hash += chars[Math.floor(Math.random() * chars.length)];
                }
                return hash;
            }
            
            // Add missing methods that are referenced in the code
            logCommand(command) {
                const terminalContent = document.getElementById('terminalContent');
                const line = document.createElement('div');
                line.className = 'terminal-line';
                line.innerHTML = `<span class="prompt">root@omega-miner:~$</span><span class="command"> ${command}</span>`;
                terminalContent.appendChild(line);
                terminalContent.scrollTop = terminalContent.scrollHeight;
            }
            
            log(message, type = 'output') {
                const terminalContent = document.getElementById('terminalContent');
                const line = document.createElement('div');
                line.className = `output ${type}`;
                line.textContent = message;
                terminalContent.appendChild(line);
                terminalContent.scrollTop = terminalContent.scrollHeight;
            }
            
            logHtml(html, type = 'output') {
                const terminalContent = document.getElementById('terminalContent');
                const line = document.createElement('div');
                line.className = `terminal-line ${type}`;
                line.innerHTML = html;
                terminalContent.appendChild(line);
                terminalContent.scrollTop = terminalContent.scrollHeight;
            }
            
            clearTerminal() {
                const terminalContent = document.getElementById('terminalContent');
                terminalContent.innerHTML = '';
            }
            
            updateConnectionStatus(status) {
                const statusElement = document.getElementById('connectionStatus');
                if (statusElement) {
                    statusElement.textContent = status;
                }
            }
            
            // Replace old showHelp with unified version
            showHelp() { this.showUnifiedHelp(); }
            
            async showBalance() {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                try {
                    const address = await this.signer.getAddress();
                    const balance = await this.provider.getBalance(address);
                    const formattedBalance = this.ethers.utils.formatEther(balance);
                    this.log(`💰 Connected Wallet Balance: ${formattedBalance} OMEGA`, 'success');
                    this.log(`📍 Connected Wallet Address: ${address}`, 'info');
                    if (this.miningWallet) {
                        const minerInfo = await this.contract.getMinerInfo(this.miningWallet.address);
                    const pendingRewards = this.ethers.utils.formatEther(minerInfo[2]);
                        this.log(`⛏️ Mining Wallet: ${this.miningWallet.address}`, 'info');
                        this.log(`💳 Pending Mining Rewards: ${pendingRewards} OMEGA`, 'info');
                    }
                } catch (error) {
                    this.log('❌ Failed to get balance: ' + error.message, 'error');
                }
            }
            
            async showStatus() {
                if (!this.signer) {
                    this.log('❌ Wallet not connected', 'error');
                    return;
                }
                
                try {
                    const address = await this.signer.getAddress();
                    this.log(`✅ Wallet: ${address}`, 'success');
                    this.log(`⛏️  Mining: ${this.isMining ? 'Active' : 'Inactive'}`, 'info');
                    this.log(`💰 Pending: ${this.totalEarned.toFixed(6)} OMEGA`, 'info');
                    this.log(`📊 Blocks Mined: ${this.mineCount || 0}`, 'info');
                } catch (error) {
                    this.log('❌ Failed to get status: ' + error.message, 'error');
                }
            }
            
            async showStats() {
                this.log('📊 Mining Statistics:', 'info');
                this.log(`⛏️  Total Blocks: ${this.mineCount || 0}`, 'output');
                this.log(`👻 Ghost Transactions: ${this.ghostTransactionCount || 0}`, 'output');
                this.log(`💰 Total Earned: ${this.totalEarned.toFixed(6)} OMEGA`, 'output');
                this.log(`⏱️  Session Time: ${this.startTime ? Math.floor((Date.now() - this.startTime) / 1000) : 0}s`, 'output');
                this.log(`🎯 Reward Structure: Avg 0.0001 | Max 1.0 OMEGA`, 'output');
            }
            
            stopAll() {
                let stoppedActivities = [];
                
                // Stop mining
                if (this.isMining) {
                    this.isMining = false;
                    if (this.miningInterval) {
                        clearInterval(this.miningInterval);
                        this.miningInterval = null;
                    }
                    stoppedActivities.push('mining');
                }
                
                // Stop stress testing
                if (this.isStressTesting) {
                    this.isStressTesting = false;
                    if (this.stressTestInterval) {
                        clearInterval(this.stressTestInterval);
                        this.stressTestInterval = null;
                    }
                    stoppedActivities.push('stress testing');
                }
                
                // Also clear stress funding interval if running
                if (this.stressFundingInterval) {
                    clearInterval(this.stressFundingInterval);
                    this.stressFundingInterval = null;
                }
                
                if (stoppedActivities.length > 0) {
                    this.log(`⏹️  Stopped: ${stoppedActivities.join(', ')}`, 'success');
                } else {
                    this.log('⏹️  No activities were running to stop', 'info');
                }
            }
            
            async startMiningSession() {
                this.log('🚀 Starting mining session...', 'info');
                await this.mine();
            }
            
            async faucetClaim() {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                if (this.sessionOmegaWallet) {
                    const approved = await this.confirmOmegaTransaction();
                    if (!approved) return;
                }
                try {
                    this.log('🚰 Claiming from faucet...', 'info');
                    const faucetContract = new this.ethers.Contract(this.faucetAddress, this.faucetABI, this.signer);
                    const tx = await faucetContract.claim({ gasLimit: 100000 });
                    await tx.wait();
                    this.log('✅ Faucet claim successful!', 'success');
                } catch (error) {
                    this.log('❌ Faucet claim failed: ' + error.message, 'error');
                }
            }
            
            async showPendingRewards() {
                const minerInfo = await this.contract.getMinerInfo(this.miningWallet.address);
                const pendingRewards = this.ethers.utils.formatEther(minerInfo[2]);
                this.log(`💰 Pending Rewards: ${pendingRewards} OMEGA`, 'info');
                if (parseFloat(pendingRewards) > 0) {
                    this.log('💡 Use "claim" command to collect rewards', 'info');
                }
            }
            
            async depositForMining() {
                this.log('💡 This feature is not yet implemented', 'info');
            }
            
            async deployContract() {
                this.log('💡 Contract deployment is handled separately', 'info');
            }
            
            async showContractInfo() {
                this.log(`📋 Mining Contract: ${this.contractAddress}`, 'info');
                this.log(`🚰 Faucet Contract: ${this.faucetAddress}`, 'info');
            }
            
            async startStressTest() {
                if (!this.ethers || !this.provider || !this.provider.getNetwork) {
                    this.log('Ethers library or provider not loaded. Please refresh the page and connect your wallet.', 'error');
                    return;
                }
                const network = await this.provider.getNetwork();
                if (!network || !network.chainId || network.chainId === 0) {
                    this.log('⚠️ No valid network detected - stress test will not send real transactions.', 'warning');
                    return;
                }
                if (this.isStressTesting) {
                    this.log('Stress test already running. Use "stopstress" to stop it.', 'warning');
                    return;
                }
                
                // Generate a new wallet for the stress test
                this.stressWallet = this.ethers.Wallet.createRandom();
                this.log('🆕 Stress Test Wallet Generated:', 'info');
                this.logHtml('Address: <span class="copyable" onclick="navigator.clipboard.writeText(\'' + this.stressWallet.address + '\').then(() => window.terminal.log(\'✅ Address copied to clipboard!\', \'success\')).catch(() => window.terminal.log(\'❌ Failed to copy address\', \'error\'))">' + this.stressWallet.address + '</span>', 'output');
                this.logHtml('💡 <span style="color:#00ff99;cursor:pointer;text-decoration:underline;" onclick="window.terminal.fundStressWallet(\'0.001\')">[Click here to fund with 0.001 OMEGA]</span>', 'info');
                
                // Connect wallet to provider
                this.stressWallet = this.stressWallet.connect(this.provider);
                
                // Wait for funding
                this.log('⏳ Waiting for funding to initiate stress test...', 'info');
                this.isStressTesting = true;
                this.stressTestStats = {
                    walletsCreated: 0,
                    transactionsSent: 0,
                    successfulTxs: 0,
                    failedTxs: 0,
                    startTime: Date.now()
                };
                
                // Poll for funding every 5 seconds
                this.stressFundingInterval = setInterval(async () => {
                    const balance = await this.provider.getBalance(this.stressWallet.address);
                    if (!balance.isZero()) {
                        clearInterval(this.stressFundingInterval);
                        this.log('✅ Funding detected! Starting stress test...', 'success');
                        // Fetch and store the starting nonce
                        this.localNonce = await this.provider.getTransactionCount(this.stressWallet.address, 'latest');
                        this.startStressTestCycle();
                    }
                }, 5000);
            }

            startStressTestCycle() {
                this.stressTestInterval = setInterval(() => {
                    if (this.isStressTesting) {
                        this.runStressTestCycle();
                    }
                }, 3000);
                this.log('✅ Stress test will now begin!', 'success');
            }

            async runStressTestCycle() {
                try {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    const newWallet = this.ethers.Wallet.createRandom();
                    this.stressTestStats.walletsCreated++;
                    const gasPrice = await this.provider.getGasPrice();

                    // Log stress wallet address and balance before sending
                    const stressAddress = this.stressWallet.address;
                    const balance = await this.provider.getBalance(stressAddress);
                    this.log(`[DEBUG] Stress wallet: ${stressAddress}, Balance: ${this.ethers.utils.formatEther(balance)} OMEGA`, 'info');
                    this.log(`[DEBUG] Provider: ${this.provider.connection && this.provider.connection.url ? this.provider.connection.url : 'unknown'}`, 'info');
                    
                    // Use and increment local nonce
                    const nonce = this.localNonce;
                    this.localNonce++;
                    
                    const txObj = {
                        to: newWallet.address,
                        value: 0,
                        gasLimit: 21000,
                        gasPrice: gasPrice,
                        nonce: nonce
                    };
                    this.log(`[DEBUG] Sending tx: ${JSON.stringify(txObj)}`, 'info');

                    const tx = await this.stressWallet.sendTransaction(txObj);
                    
                    this.stressTestStats.transactionsSent++;
                    this.log(`📤 Sent empty tx to ${newWallet.address.slice(0, 10)}... (hash: ${tx.hash})`, 'info');
                    this.stressTestStats.successfulTxs++;
                } catch (err) {
                    this.stressTestStats.failedTxs++;
                    this.log(`[DEBUG] Error: ${err && err.stack ? err.stack : err}`, 'error');
                    // If nonce error, re-sync local nonce
                    if (err.message && (err.message.includes('nonce') || err.message.includes('replacement'))) {
                        this.log('🔄 Nonce error detected, re-syncing nonce from network...', 'warning');
                        this.localNonce = await this.provider.getTransactionCount(this.stressWallet.address, 'latest');
                    } else if (err.message && err.message.includes('Internal JSON-RPC error')) {
                        this.log(`⚠️ RPC overload - slowing down...`, 'warning');
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    } else {
                        this.log(`❌ Transaction failed: ${err.message}`, 'error');
                    }
                }
            }

            stopStressTest() {
                if (!this.isStressTesting) {
                    this.log('No stress test running.', 'warning');
                    return;
                }
                
                if (this.stressTestInterval) {
                    clearInterval(this.stressTestInterval);
                }
                if (this.stressFundingInterval) {
                    clearInterval(this.stressFundingInterval);
                }
                
                this.isStressTesting = false;
                this.log('🛑 Stress test stopped.', 'warning');
                this.showStressStats();
            }
            
            showStressStats() {
                if (!this.stressTestStats.startTime) {
                    this.log('No stress test has been run yet.', 'info');
                    return;
                }
                
                const runtime = Math.floor((Date.now() - this.stressTestStats.startTime) / 1000);
                const successRate = this.stressTestStats.transactionsSent > 0 
                    ? ((this.stressTestStats.successfulTxs / this.stressTestStats.transactionsSent) * 100).toFixed(1)
                    : 0;
                
                this.log('=== STRESS TEST STATISTICS ===', 'info');
                this.log(`Runtime: ${runtime} seconds`, 'output');
                this.log(`Wallets Created: ${this.stressTestStats.walletsCreated}`, 'output');
                this.log(`Transactions Sent: ${this.stressTestStats.transactionsSent}`, 'output');
                this.log(`Successful: ${this.stressTestStats.successfulTxs}`, 'success');
                this.log(`Failed: ${this.stressTestStats.failedTxs}`, 'error');
                this.log(`Success Rate: ${successRate}%`, 'output');
                this.log(`Status: ${this.isStressTesting ? 'RUNNING' : 'STOPPED'}`, this.isStressTesting ? 'success' : 'warning');
            }
            
            async showMiningStats() {
                await this.showStats();
            }
            
            async rickroll() {
                this.log('🎵 Never gonna give you up...', 'info');
                this.log('🎵 Never gonna let you down...', 'info');
                this.log('🎵 Never gonna run around and desert you...', 'info');
                this.log('🎵 Never gonna make you cry...', 'info');
                this.log('🎵 Never gonna say goodbye...', 'info');
                this.log('🎵 Never gonna tell a lie and hurt you...', 'info');
            }
            
            fortune() {
                const fortunes = [
                    "A beautiful, smart, and loving person will be coming into your life.",
                    "A dubious friend may be an enemy in camouflage.",
                    "A faithful friend is a strong defense.",
                    "A fresh start will put you on your way.",
                    "A golden egg of opportunity falls into your lap this month.",
                    "A lifetime friend shall soon be made.",
                    "A light heart carries you through all the hard times.",
                    "A new perspective will come with the new year.",
                    "A pleasant surprise is waiting for you.",
                    "A short pencil is usually better than a long memory any day."
                ];
                const fortune = fortunes[Math.floor(Math.random() * fortunes.length)];
                this.log(`🔮 Fortune: ${fortune}`, 'info');
            }
            
            async matrix() {
                this.log('🌐 Entering the Matrix...', 'info');
                for (let i = 0; i < 5; i++) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    this.log('01010101010101010101010101010101', 'output');
                }
                this.log('🌐 Matrix mode activated!', 'success');
            }
            
            async hack() {
                this.log('💻 Hacker mode activated...', 'info');
                this.log('🔓 Bypassing security protocols...', 'output');
                this.log('🔓 Accessing mainframe...', 'output');
                this.log('🔓 Downloading classified data...', 'output');
                this.log('✅ Hack complete! You are now a l33t h4x0r!', 'success');
            }
            
            async disco() {
                this.log('🕺 Disco mode activated!', 'info');
                this.log('💃 Stayin\' alive, stayin\' alive...', 'output');
                this.log('🎵 Ah, ha, ha, ha, stayin\' alive, stayin\' alive...', 'output');
                this.log('✨ Disco fever!', 'success');
            }
            
            sudoMine() {
                this.log('🔐 Sudo access granted!', 'info');
                this.log('⚡ Super user mining mode activated!', 'success');
                this.log('🚀 Mining with admin privileges...', 'output');
                this.totalEarned += 0.1;
                this.log('💰 Admin bonus: +0.1 OMEGA', 'success');
            }

            async fundMiningWallet(amount) {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                if (!this.miningWallet) {
                    this.log('No mining wallet found. Start mining first.', 'error');
                    return;
                }
                if (!amount || isNaN(amount) || Number(amount) <= 0) {
                    this.log('Invalid amount. Usage: fund <amount>', 'error');
                    return;
                }
                try {
                    this.log(`💰 Funding mining wallet with ${amount} OMEGA...`, 'info');
                    const tx = await this.signer.sendTransaction({
                        to: this.miningWallet.address,
                        value: this.ethers.utils.parseEther(amount),
                        gasLimit: 21000
                    });
                    this.log(`📤 Funding transaction sent: ${tx.hash}`, 'info');
                    this.log('⏳ Waiting for confirmation... (this may take a few seconds)', 'info');
                    await tx.wait();
                    this.log(`✅ Mining wallet funded with ${amount} OMEGA!`, 'success');
                } catch (error) {
                    if (error.code === 4001) {
                        this.log('❌ Transaction rejected by user.', 'error');
                    } else {
                    this.log('❌ Failed to fund mining wallet: ' + error.message, 'error');
                    }
                }
            }

            async fundStressWallet(amount) {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                if (!this.stressWallet) {
                    this.log('No stress test wallet found. Start stress test first.', 'error');
                    return;
                }
                if (!amount || isNaN(amount) || Number(amount) <= 0) {
                    this.log('Invalid amount. Usage: fund <amount>', 'error');
                    return;
                }
                try {
                    this.log(`💰 Funding stress test wallet with ${amount} OMEGA...`, 'info');
                    const tx = await this.signer.sendTransaction({
                        to: this.stressWallet.address,
                        value: this.ethers.utils.parseEther(amount),
                        gasLimit: 21000
                    });
                    this.log(`📤 Funding transaction sent: ${tx.hash}`, 'info');
                    this.log('⏳ Waiting for confirmation... (this may take a few seconds)', 'info');
                    await tx.wait();
                    this.log(`✅ Stress test wallet funded with ${amount} OMEGA!`, 'success');
                } catch (error) {
                    if (error.code === 4001) {
                        this.log('❌ Transaction rejected by user.', 'error');
                    } else {
                        this.log('❌ Failed to fund stress test wallet: ' + error.message, 'error');
                    }
                }
            }

            async setTheme(theme) {
                const validThemes = ['dark', 'light', 'matrix', 'retro'];
                if (!validThemes.includes(theme)) {
                    this.log('Invalid theme. Available: dark, light, matrix, retro', 'error');
                    return;
                }
                document.body.classList.remove('theme-dark', 'theme-light', 'theme-matrix', 'theme-retro');
                document.body.classList.add('theme-' + theme);
                const terminal = document.getElementById('terminal');
                if (terminal) {
                    terminal.classList.remove('theme-dark', 'theme-light', 'theme-matrix', 'theme-retro');
                    terminal.classList.add('theme-' + theme);
                }
                localStorage.setItem('omega-terminal-theme', theme);
                this.log(`Theme set to ${theme} mode`, 'success');
            }

            toggleTheme() {
                this.isDarkTheme = !this.isDarkTheme;
                this.applyTheme();
                localStorage.setItem('omega-miner-theme', this.isDarkTheme ? 'dark' : 'light');
            }
            
            applyTheme() {
                const theme = localStorage.getItem('omega-terminal-theme') || 'dark';
                document.body.classList.remove('theme-dark', 'theme-light', 'theme-matrix', 'theme-retro');
                document.body.classList.add('theme-' + theme);
                const terminal = document.getElementById('terminal');
                if (terminal) {
                    terminal.classList.remove('theme-dark', 'theme-light', 'theme-matrix', 'theme-retro');
                    terminal.classList.add('theme-' + theme);
                }
                const themeToggle = document.querySelector('.theme-toggle');
                if (themeToggle) {
                    if (theme === 'dark') themeToggle.textContent = '☀️ Light';
                    else if (theme === 'light') themeToggle.textContent = '🌙 Dark';
                    else if (theme === 'matrix') themeToggle.textContent = '🟩 Matrix';
                    else if (theme === 'retro') themeToggle.textContent = '🟨 Retro';
                }
            }

            async sendOmega(command) {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                // Parse command: send <address_or_ens> <amount>
                const parts = command.trim().split(/\s+/);
                if (parts.length !== 3) {
                    this.log('Usage: send <address_or_ens> <amount>', 'warning');
                    return;
                }
                let address = parts[1];
                const amountStr = parts[2];
                
                // First, try to resolve as ENS name if it's not a valid address
                if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
                    this.log(`🔍 Resolving ENS name: ${address}...`, 'info');
                    try {
                        const ens = this.getENSContract();
                        const resolvedAddress = await ens.resolve(address);
                        if (resolvedAddress && resolvedAddress !== '0x0000000000000000000000000000000000000000') {
                            this.log(`✅ Resolved ${address} to ${resolvedAddress}`, 'success');
                            address = resolvedAddress;
                        } else {
                            this.log(`❌ ENS name not found: ${address}`, 'error');
                            return;
                        }
                    } catch (err) {
                        this.log(`❌ Failed to resolve ENS name: ${err.message}`, 'error');
                        return;
                    }
                }
                
                // Now validate the resolved address
                if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
                    this.log('Invalid address format.', 'error');
                    return;
                }
                
                let amount;
                try {
                    amount = this.ethers.utils.parseEther(amountStr);
                } catch (e) {
                    this.log('Invalid amount.', 'error');
                    return;
                }
                
                this.log(`🚀 Sending ${amountStr} OMEGA to ${address}...`, 'info');
                try {
                    const tx = await this.signer.sendTransaction({
                        to: address,
                        value: amount
                    });
                    this.log('⏳ Waiting for confirmation...', 'info');
                    await tx.wait();
                    this.log(`✅ Sent ${amountStr} OMEGA to ${address}!`, 'success');
                } catch (error) {
                    this.log('❌ Send failed: ' + error.message, 'error');
                }
            }

            async claim() {
                if (!this.signer) {
                    this.log('Please connect wallet first using "connect" command', 'error');
                    return;
                }
                if (!this.miningWallet) {
                    this.log('No mining wallet found. Start mining first.', 'error');
                    return;
                }
                try {
                    const wasMining = this.isMining;
                    if (wasMining) this.isMining = false;
                    const miningAddress = this.miningWallet.address;
                    const userAddress = await this.signer.getAddress();
                    this.log(`💰 Claiming rewards from mining wallet (${miningAddress}) to your wallet (${userAddress})...`, 'info');
                    // Claim rewards from contract
                    const minerInfo = await this.contract.getMinerInfo(miningAddress);
                    const pendingRewards = minerInfo[2];
                    if (pendingRewards.isZero()) {
                        this.log('⚠️ No pending rewards found in contract for mining wallet.', 'warning');
                        return;
                    }
                    // Log mining wallet balance and estimated gas
                    const balance = await this.provider.getBalance(miningAddress);
                    const gasPrice = await this.provider.getGasPrice();
                    const gasLimit = 100000;
                    const minClaimGas = this.ethers.utils.parseEther('0.002');
                    const estimatedGas = gasPrice.mul(gasLimit);
                    this.log(`Mining wallet balance: ${this.ethers.utils.formatEther(balance)} OMEGA`, 'info');
                    this.log(`Estimated gas required for claim: ${this.ethers.utils.formatEther(estimatedGas)} OMEGA`, 'info');
                    if (balance.lt(minClaimGas)) {
                        this.log('⚠️ Not enough OMEGA in mining wallet to pay gas for claim. Please fund it with at least 0.002 OMEGA.', 'warning');
                        return;
                    }
                    const claimTx = await this.contract.connect(this.miningWallet).claimTo(userAddress, { gasLimit });
                    await claimTx.wait();
                    this.logHtml(`Transaction hash: <span class=\"copyable\" onclick=\"navigator.clipboard.writeText('${claimTx.hash}').then(() => window.terminal.log('✅ Transaction hash copied to clipboard!', 'success')).catch(() => window.terminal.log('❌ Failed to copy transaction hash', 'error'))\">${claimTx.hash}</span>`, 'info');
                    const updatedMinerInfo = await this.contract.getMinerInfo(this.miningWallet.address);
                    this.totalEarned = parseFloat(this.ethers.utils.formatEther(updatedMinerInfo[2]));
                    if (wasMining) this.isMining = true;
                } catch (error) {
                    this.log(`❌ Claim failed: ${error.message}`, 'error');
                }
            }

            // 1. Add ENS contract setup at the top of the class (after constructor or as a helper):
            getENSContract(signerOrProvider) {
                const abi = [
                    {"anonymous":false,"inputs":[{"indexed":true,"internalType":"string","name":"name","type":"string"},{"indexed":true,"internalType":"address","name":"owner","type":"address"}],"name":"NameRegistered","type":"event"},
                    {"inputs":[{"internalType":"string","name":"name","type":"string"}],"name":"register","outputs":[],"stateMutability":"nonpayable","type":"function"},
                    {"inputs":[{"internalType":"string","name":"name","type":"string"},{"internalType":"address","name":"newOwner","type":"address"}],"name":"transfer","outputs":[],"stateMutability":"nonpayable","type":"function"},
                    {"inputs":[{"internalType":"string","name":"","type":"string"}],"name":"names","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
                    {"inputs":[{"internalType":"string","name":"name","type":"string"}],"name":"resolve","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}
                ];
                return new this.ethers.Contract('0xd9ce49734db4f033362d2fd51d52f24cabeb87fa', abi, signerOrProvider || this.signer || this.provider);
            }

            // Chat functionality
            async sendDirectMessage(recipient, message) {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                // Resolve ENS if needed
                let toAddress = recipient;
                if (!/^0x[a-fA-F0-9]{40}$/.test(recipient)) {
                    try {
                        const ens = this.getENSContract();
                        const resolved = await ens.resolve(recipient);
                        if (resolved && resolved !== '0x0000000000000000000000000000000000000000') {
                            toAddress = resolved;
                        } else {
                            this.log('❌ ENS name not found: ' + recipient, 'error');
                            return;
                        }
                    } catch (err) {
                        this.log('❌ Failed to resolve ENS: ' + err.message, 'error');
                        return;
                    }
                }
                // Send DM on-chain
                try {
                    const dmABI = [
                        {
                            "inputs": [
                                { "internalType": "address", "name": "to", "type": "address" },
                                { "internalType": "string", "name": "ensName", "type": "string" },
                                { "internalType": "string", "name": "message", "type": "string" }
                            ],
                            "name": "sendMessage",
                            "outputs": [],
                            "stateMutability": "nonpayable",
                            "type": "function"
                        },
                        {
                            "anonymous": false,
                            "inputs": [
                                { "indexed": true, "internalType": "address", "name": "from", "type": "address" },
                                { "indexed": true, "internalType": "address", "name": "to", "type": "address" },
                                { "indexed": false, "internalType": "string", "name": "message", "type": "string" },
                                { "indexed": false, "internalType": "uint256", "name": "timestamp", "type": "uint256" }
                            ],
                            "name": "DirectMessage",
                            "type": "event"
                        }
                    ];
                    const dmContract = new this.ethers.Contract('0x26e31516e5e7790f8aaa35278735970a93fee213', dmABI, this.signer);
                    let tx;
                    if (/^0x[a-fA-F0-9]{40}$/.test(recipient)) {
                        // It's an address
                        tx = await dmContract.sendMessage(recipient, '', message);
                    } else {
                        // It's an ENS name
                        tx = await dmContract.sendMessage('0x0000000000000000000000000000000000000000', recipient, message);
                    }
                    this.log('⏳ Sending Email on-chain... (tx: ' + tx.hash + ')', 'info');
                    await tx.wait();
                    this.log('✅ Email sent!', 'success');
                } catch (err) {
                    this.log('❌ Failed to send DM: ' + err.message, 'error');
                }
            }

            async showInbox() {
                try {
                    const dmABI = [
                        {
                            "inputs": [
                                { "internalType": "address", "name": "to", "type": "address" },
                                { "internalType": "string", "name": "ensName", "type": "string" },
                                { "internalType": "string", "name": "message", "type": "string" }
                            ],
                            "name": "sendMessage",
                            "outputs": [],
                            "stateMutability": "nonpayable",
                            "type": "function"
                        },
                        {
                            "anonymous": false,
                            "inputs": [
                                { "indexed": true, "internalType": "address", "name": "from", "type": "address" },
                                { "indexed": true, "internalType": "address", "name": "to", "type": "address" },
                                { "indexed": false, "internalType": "string", "name": "message", "type": "string" },
                                { "indexed": false, "internalType": "uint256", "name": "timestamp", "type": "uint256" }
                            ],
                            "name": "DirectMessage",
                            "type": "event"
                        }
                    ];
                    const dmContract = new this.ethers.Contract('0x26e31516e5e7790f8aaa35278735970a93fee213', dmABI, this.provider);
                    const myAddr = await this.signer.getAddress();
                    const filter = dmContract.filters.DirectMessage(null, myAddr);
                    const events = await dmContract.queryFilter(filter, -10000); // last 10k blocks
                    if (!events.length) {
                        this.log('No direct messages found.', 'info');
                        return;
                    }
                    this.log('=== Inbox ===', 'info');
                    // Show last 10 messages
                    for (let i = 0; i < events.slice(-10).length; i++) {
                        const ev = events.slice(-10)[i];
                        let from = ev.args.from;
                        let ensName = '';
                        try {
                            ensName = await this.provider.lookupAddress(from);
                        } catch {}
                        let fromDisplay = ensName ? `(${ensName}) | ${from}` : from;
                        this.log('──────────────────────────────', 'output');
                        this.logHtml(
                            `<span id="${ev.transactionHash}"><span style="color:#fff">📧</span> <span style="color:#99ccff">From:</span> <span style="color:#fff">${fromDisplay}</span><br><span style="color:#99ccff">Time:</span> <span style="color:#fff">${new Date(Number(ev.args.timestamp) * 1000).toISOString().replace('T', ' ').replace('Z', ' UTC')}</span><br><span style="color:#99ccff">Message:</span> <span style="color:#fff">${ev.args.message}</span><br><span style="color:#00ff99;cursor:pointer;text-decoration:underline;" onclick="document.getElementById('${ev.transactionHash}').style.display='none'">Delete</span> | <span style="color:#00ccff;cursor:pointer;text-decoration:underline;" onclick="window.terminal.prefillOeMailRecipient('${from}')">Reply</span></span>`,
                            'output'
                        );
                    }
                    this.log('Fetching inbox events...', 'info');
                    console.log('DM events:', events);
                } catch (err) {
                    this.log('❌ Failed to fetch inbox: ' + err.message, 'error');
                }
            }

            prefillOeMailRecipient(address) {
                const input = document.getElementById('commandInput');
                if (input) {
                    window.terminal.tempDMRecipient = address;
                    window.terminal.awaitingDMRecipient = false;
                    window.terminal.awaitingDMMessage = true;
                    window.terminal.logHtml('<span style="color:#99ccff">Recipient:</span> <span style="color:#fff">' + address + '</span>', 'info');
                    window.terminal.log('Enter your message:', 'info');
                    input.value = '';
                    input.focus();
                }
            }

            async showFaucetStatus() {
                if (!this.signer) {
                    this.log('Please connect your wallet first using: connect', 'error');
                    return;
                }
                try {
                    const address = await this.signer.getAddress();
                    const faucetContract = new this.ethers.Contract(this.faucetAddress, this.faucetABI, this.signer);
                    // Get claim info
                    const info = await faucetContract.getFaucetStatus(address);
                    const canClaim = info.canClaimNow;
                    const lastClaim = info.lastClaim;
                    const timeUntil = info.timeUntilNextClaim;
                    const claimAmount = info.claimAmount;
                    // Get faucet balance
                    const balance = await faucetContract.getFaucetBalance();
                    this.log('=== Faucet Status ===', 'info');
                    this.log(`Can claim now: ${canClaim ? '✅ Yes' : '❌ No'}`, canClaim ? 'success' : 'error');
                    if (!canClaim) {
                        const mins = Math.floor(timeUntil / 60);
                        const secs = timeUntil % 60;
                        this.log(`Time until next claim: ${mins}m ${secs}s`, 'warning');
                    }
                    this.log(`Faucet balance: ${this.ethers.utils.formatEther(balance)} OMEGA`, 'info');
                    this.log(`Claim amount: ${this.ethers.utils.formatEther(claimAmount)} OMEGA`, 'info');
                } catch (error) {
                    this.log('❌ Failed to fetch faucet status: ' + error.message, 'error');
                }
            }

            // Add this helper method to the class
            async isRealMetaMask() {
                if (typeof window.ethereum !== 'undefined' && window.ethereum.isMetaMask) {
                    try {
                        await window.ethereum.request({ method: 'eth_accounts' });
                        return true;
                    } catch (e) {
                        this.log('DEBUG: eth_accounts call failed, MetaMask not real', 'info');
                        return false;
                    }
                }
                return false;
            }

            // Add this method to the OmegaMinerTerminal class
            promptTerminalInput() {
                this.awaitingPromptInput = true;
                return new Promise((resolve) => {
                    this.promptResolver = resolve;
                    const input = document.getElementById('commandInput');
                    input.focus();
                });
            }

            // Add a helper to confirm transactions for Omega Test Wallet
            async confirmOmegaTransaction() {
                if (this.sessionOmegaWallet) {
                    this.log('Approve transaction? (yes / no)', 'warning');
                    while (true) {
                        const input = await this.promptTerminalInput();
                        if (input.toLowerCase() === 'yes') return true;
                        if (input.toLowerCase() === 'no') {
                            this.log('Transaction cancelled.', 'error');
                            return false;
                        }
                        this.log('Please type either "yes" or "no".', 'warning');
                    }
                }
                return true;
            }

            async handleDexScreenerAlias(args) {
                if (args[1] === 'help') {
                    this.logHtml('<span style="color:#33bbff">Dexscreener API Commands:</span>', 'info');
                    this.logHtml('<span style="color:#99ccff">ds trending</span> - Show trending tokens', 'output');
                    this.logHtml('<span style="color:#99ccff">ds search [query]</span> - Search for tokens', 'output');
                    this.logHtml('<span style="color:#99ccff">ds pair [chainId] [pairId]</span> - Get pair info', 'output');
                    this.logHtml('<span style="color:#99ccff">ds pools</span> - List all pools', 'output');
                    this.logHtml('<span style="color:#99ccff">ds pools [chainId] [tokenAddress]</span> - Get pools for a token', 'output');
                    this.logHtml('<br><span style="color:#33bbff">Examples:</span>', 'info');
                    this.logHtml('<span style="color:#99ccff">ds trending</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">ds search OMEGA</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">ds pair 1 0x123...</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">ds pools</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">ds pools 1 0x123...</span>', 'output');
                    return;
                }
                // Map ds commands to relayer endpoints
                if (args[1] === 'trending') {
                    await this.handleDexScreenerCommand(['dexscreener', 'trending']);
                } else if (args[1] === 'search' && args[2]) {
                    await this.handleDexScreenerCommand(['dexscreener', 'search', ...args.slice(2)]);
                } else if (args[1] === 'pair' && args[2] && args[3]) {
                    // /dex/pair/:chainId/:pairId
                    const chainId = args[2];
                    const pairId = args[3];
                    this.log(`Fetching DexScreener pair info for chain ${chainId}, pair ${pairId}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/dex/pair/${chainId}/${pairId}`);
                        const data = await res.json();
                        this.logHtml(`<pre>${JSON.stringify(data, null, 2)}</pre>`, 'output');
                    } catch (e) {
                        this.log('DexScreener pair fetch failed: ' + e.message, 'error');
                    }
                } else if (args[1] === 'pools' && !args[2]) {
                    // /dex/pools
                    this.log('Fetching all DexScreener pools...', 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/dex/pools`);
                        const data = await res.json();
                        this.logHtml(`<pre>${JSON.stringify(data, null, 2)}</pre>`, 'output');
                    } catch (e) {
                        this.log('DexScreener pools fetch failed: ' + e.message, 'error');
                    }
                } else if (args[1] === 'pools' && args[2] && args[3]) {
                    // /dex/pools/:chainId/:tokenAddress
                    const chainId = args[2];
                    const tokenAddress = args[3];
                    this.log(`Fetching DexScreener pools for chain ${chainId}, token ${tokenAddress}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/dex/pools/${chainId}/${tokenAddress}`);
                        const data = await res.json();
                        this.logHtml(`<pre>${JSON.stringify(data, null, 2)}</pre>`, 'output');
                    } catch (e) {
                        this.log('DexScreener pools fetch failed: ' + e.message, 'error');
                    }
                } else {
                    this.log('Type ds help for available commands.', 'info');
                }
            }

            async handleGeckoTerminalAlias(args) {
                if (args[1] === 'help') {
                    this.logHtml('<span style="color:#33bbff">GeckoTerminal API Commands:</span>', 'info');
                    this.logHtml('<span style="color:#99ccff">cg search [query]</span> - Search for pairs', 'output');
                    this.logHtml('<span style="color:#99ccff">cg networks</span> - List networks', 'output');
                    this.logHtml('<span style="color:#99ccff">cg dexes [network]</span> - List dexes for a network', 'output');
                    this.logHtml('<span style="color:#99ccff">cg pools [network]</span> - List pools for a network', 'output');
                    this.logHtml('<span style="color:#99ccff">cg token [network] [address]</span> - Get token info', 'output');
                    this.logHtml('<span style="color:#99ccff">cg tokenpools [network] [token_address]</span> - Get pools for a token', 'output');
                    this.logHtml('<span style="color:#99ccff">cg poolinfo [network] [pool_address]</span> - Get pool info', 'output');
                    this.logHtml('<span style="color:#99ccff">cg ohlcv [network] [pool_address] [timeframe]</span> - Get OHLCV data', 'output');
                    this.logHtml('<span style="color:#99ccff">cg trades [network] [pool_address]</span> - Get trades for a pool', 'output');
                    this.logHtml('<br><span style="color:#33bbff">Examples:</span>', 'info');
                    this.logHtml('<span style="color:#99ccff">cg search OMEGA</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">cg networks</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">cg dexes ethereum</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">cg pools ethereum</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">cg token ethereum 0x123...</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">cg tokenpools ethereum 0x123...</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">cg poolinfo ethereum 0xabc...</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">cg ohlcv ethereum 0xabc... 1d</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">cg trades ethereum 0xabc...</span>', 'output');
                    return;
                }
                // Map cg commands to relayer endpoints
                if (args[1] === 'search' && args[2]) {
                    await this.handleGeckoTerminalCommand(['geckoterminal', 'search', ...args.slice(2)]);
                } else if (args[1] === 'networks') {
                    this.log('Fetching GeckoTerminal networks...', 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml('<b>Available Networks:</b>', 'output');
                            data.data.forEach((item) => {
                                const net = item.attributes;
                                const id = item.id;
                                const cg = net.coingecko_asset_platform_id ? ` | Coingecko: <b>${net.coingecko_asset_platform_id}</b>` : '';
                                this.logHtml(`<b>${net.name}</b> (<span style='color:#99ccff'>${id}</span>)${cg}`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No networks found.</span>', 'error');
                        }
                    } catch (e) {
                        this.log('GeckoTerminal networks fetch failed: ' + e.message, 'error');
                    }
                } else if (args[1] === 'dexes' && args[2]) {
                    const network = args[2];
                    this.log(`Fetching GeckoTerminal dexes for network: ${network}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/dexes`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml(`<b>DEXes for ${network}:</b>`, 'output');
                            data.data.forEach((item) => {
                                const dex = item.attributes;
                                const id = item.id;
                                this.logHtml(`<b>${dex.name}</b> (<span style='color:#99ccff'>${id}</span>)`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No DEXes found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal dexes fetch failed: ' + e.message, 'error');
                    }
                } else if (args[1] === 'pools' && args[2]) {
                    const network = args[2];
                    this.log(`Fetching GeckoTerminal pools for network: ${network}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/pools`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml(`<b>Pools for ${network}:</b>`, 'output');
                            data.data.forEach((item) => {
                                const pool = item.attributes;
                                this.logHtml(`<b>${pool.name}</b> | DEX: <b>${pool.dex_name}</b> | TVL: <b>${pool.tvl_usd || 'N/A'}</b>`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No pools found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal pools fetch failed: ' + e.message, 'error');
                    }
                } else if (args[1] === 'token' && args[2] && args[3]) {
                    const network = args[2];
                    const address = args[3];
                    this.log(`Fetching GeckoTerminal token info for network: ${network}, address: ${address}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/tokens/${address}`);
                        const data = await res.json();
                        if (data && data.data && data.data.attributes) {
                            const token = data.data.attributes;
                            this.logHtml(`<b>${token.name} (${token.symbol})</b>`, 'output');
                            this.logHtml(`Price: <b>${token.price_usd || 'N/A'}</b> | TVL: <b>${token.tvl_usd || 'N/A'}</b>`, 'output');
                            this.logHtml(`DEX Count: <b>${token.dex_count || 'N/A'}</b> | Pool Count: <b>${token.pool_count || 'N/A'}</b>`, 'output');
                            if (token.gecko_terminal_url) this.logHtml(`<a href="${token.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`, 'output');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No token info found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal token fetch failed: ' + e.message, 'error');
                    }
                } else if (args[1] === 'tokenpools' && args[2] && args[3]) {
                    const network = args[2];
                    const tokenAddress = args[3];
                    this.log(`Fetching GeckoTerminal pools for token: ${tokenAddress} on network: ${network}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/tokens/${tokenAddress}/pools`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml(`<b>Pools for token ${tokenAddress} on ${network}:</b>`, 'output');
                            data.data.forEach((item) => {
                                const pool = item.attributes;
                                this.logHtml(`<b>${pool.name}</b> | DEX: <b>${pool.dex_name}</b> | TVL: <b>${pool.tvl_usd || 'N/A'}</b>`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No pools found for this token.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal tokenpools fetch failed: ' + e.message, 'error');
                    }
                } else if (args[1] === 'poolinfo' && args[2] && args[3]) {
                    const network = args[2];
                    const poolAddress = args[3];
                    this.log(`Fetching GeckoTerminal pool info for network: ${network}, pool: ${poolAddress}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/info`);
                        const data = await res.json();
                        if (data && data.data && data.data.attributes) {
                            const pool = data.data.attributes;
                            this.logHtml(`<b>${pool.name}</b> | DEX: <b>${pool.dex_name}</b> | TVL: <b>${pool.tvl_usd || 'N/A'}</b>`, 'output');
                            this.logHtml(`Base: <b>${pool.base_token_symbol}</b> | Quote: <b>${pool.quote_token_symbol}</b>`, 'output');
                            this.logHtml(`Price: <b>${pool.price_usd || 'N/A'}</b> | Volume 24h: <b>${pool.volume_usd_24h || 'N/A'}</b>`, 'output');
                            if (pool.gecko_terminal_url) this.logHtml(`<a href="${pool.gecko_terminal_url}" target="_blank">View on GeckoTerminal</a>`, 'output');
                        } else {
                            this.logHtml('<span style="color:#ff3333">No pool info found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal poolinfo fetch failed: ' + e.message, 'error');
                    }
                } else if (args[1] === 'ohlcv' && args[2] && args[3] && args[4]) {
                    const network = args[2];
                    const poolAddress = args[3];
                    const timeframe = args[4];
                    this.log(`Fetching GeckoTerminal OHLCV for network: ${network}, pool: ${poolAddress}, timeframe: ${timeframe}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/ohlcv/${timeframe}`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml(`<b>OHLCV (${timeframe}) for pool ${poolAddress}:</b>`, 'output');
                            data.data.forEach((item) => {
                                this.logHtml(`<b>${item.timestamp}</b>: O: <b>${item.open}</b>, H: <b>${item.high}</b>, L: <b>${item.low}</b>, C: <b>${item.close}</b>, V: <b>${item.volume}</b>`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No OHLCV data found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal ohlcv fetch failed: ' + e.message, 'error');
                    }
                } else if (args[1] === 'trades' && args[2] && args[3]) {
                    const network = args[2];
                    const poolAddress = args[3];
                    this.log(`Fetching GeckoTerminal trades for network: ${network}, pool: ${poolAddress}`, 'info');
                    try {
                        const res = await fetch(`${RELAYER_URL}/gecko/networks/${network}/pools/${poolAddress}/trades`);
                        const data = await res.json();
                        if (data && data.data && Array.isArray(data.data) && data.data.length > 0) {
                            this.logHtml(`<b>Recent trades for pool ${poolAddress}:</b>`, 'output');
                            data.data.slice(0, 10).forEach((item) => {
                                const trade = item.attributes;
                                this.logHtml(`<b>${trade.timestamp}</b>: <b>${trade.amount_usd || 'N/A'} USD</b> | Type: <b>${trade.trade_type}</b> | Price: <b>${trade.price_usd || 'N/A'}</b>`, 'output');
                            });
                        } else {
                            this.logHtml('<span style="color:#ff3333">No trades found.</span>', 'error');
                        }
                        show404Suggestion(data);
                    } catch (e) {
                        this.log('GeckoTerminal trades fetch failed: ' + e.message, 'error');
                    }
                } else {
                    this.log('Type cg help for available commands.', 'info');
                }
            }

            async handleAlphaAlias(args) {
                if (args[1] === 'help') {
                    this.logHtml('<span style="color:#33bbff">Alpha Vantage API Commands:</span>', 'info');
                    this.logHtml('<span style="color:#99ccff">alpha quote [symbol]</span> - Get stock quote', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha search [query]</span> - Search for stocks', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha daily [symbol]</span> - Get daily stock data', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha overview [symbol]</span> - Get stock overview', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha inflation</span> - Get US inflation data', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha cpi</span> - Get US CPI data', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha gdp</span> - Get US GDP data', 'output');
                    this.logHtml('<br><span style="color:#33bbff">Examples:</span>', 'info');
                    this.logHtml('<span style="color:#99ccff">alpha quote IBM</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha search Microsoft</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha daily TSLA</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha overview AAPL</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha inflation</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha cpi</span>', 'output');
                    this.logHtml('<span style="color:#99ccff">alpha gdp</span>', 'output');
                    return;
                }
                // Map alpha commands to relayer endpoints
                if (args[1] === 'quote' && args[2]) {
                    await this.handleStockCommand(['stock', 'quote', args[2]]);
                } else if (args[1] === 'search' && args[2]) {
                    await this.handleStockCommand(['stock', 'search', ...args.slice(2)]);
                } else if (args[1] === 'daily' && args[2]) {
                    await this.handleStockCommand(['stock', 'daily', args[2]]);
                } else if (args[1] === 'overview' && args[2]) {
                    await this.handleStockCommand(['stock', 'overview', args[2]]);
                } else if (args[1] === 'inflation') {
                    await this.handleStockCommand(['stock', 'inflation']);
                } else if (args[1] === 'cpi') {
                    await this.handleStockCommand(['stock', 'cpi']);
                } else if (args[1] === 'gdp') {
                    await this.handleStockCommand(['stock', 'gdp']);
                } else {
                    this.log('Type alpha help for available commands.', 'info');
                }
            }

            async handleCreateCommand(args) {
                if (!this.provider || !this.signer) {
                    this.log('Please connect your wallet first using "connect"', 'error');
                    return;
                }

                // OmegaTokenFactory contract details
                const FACTORY_ADDRESS = '0x1f568dbb3a7b9ea05062b132094a848ef1443cfe';
                const FACTORY_ABI = [
                  {
                    "inputs": [
                      { "internalType": "string", "name": "name_", "type": "string" },
                      { "internalType": "string", "name": "symbol_", "type": "string" },
                      { "internalType": "uint8", "name": "decimals_", "type": "uint8" },
                      { "internalType": "uint256", "name": "initialSupply_", "type": "uint256" },
                      { "internalType": "bool", "name": "mintable_", "type": "bool" },
                      { "internalType": "bool", "name": "pausable_", "type": "bool" }
                    ],
                    "name": "createToken",
                    "outputs": [ { "internalType": "address", "name": "", "type": "address" } ],
                    "stateMutability": "nonpayable",
                    "type": "function"
                  },
                  {
                    "anonymous": false,
                    "inputs": [
                      { "indexed": true, "internalType": "address", "name": "creator", "type": "address" },
                      { "indexed": false, "internalType": "address", "name": "token", "type": "address" },
                      { "indexed": false, "internalType": "string", "name": "name", "type": "string" },
                      { "indexed": false, "internalType": "string", "name": "symbol", "type": "string" }
                    ],
                    "name": "TokenCreated",
                    "type": "event"
                  },
                  {
                    "inputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ],
                    "name": "allTokens",
                    "outputs": [ { "internalType": "address", "name": "", "type": "address" } ],
                    "stateMutability": "view",
                    "type": "function"
                  },
                  {
                    "inputs": [],
                    "name": "getAllTokens",
                    "outputs": [ { "internalType": "address[]", "name": "", "type": "address[]" } ],
                    "stateMutability": "view",
                    "type": "function"
                  }
                ];

                try {
                    this.log('🚀 Omega Token Creator', 'info');
                    this.log('This will deploy a new ERC20 token on the Omega Network', 'info');
                    this.log('', 'info');

                    // Get token name
                    this.log('Enter token name (e.g., "My Awesome Token"):', 'info');
                    let name = await this.promptTerminalInput('Enter token name (e.g., "My Awesome Token"):');
                    name = name ? name.trim() : '';
                    if (!name) {
                        this.log('Token creation cancelled.', 'warning');
                        return;
                    }
                    document.getElementById('commandInput').value = '';

                    // Get token symbol
                    this.log('Enter token symbol (e.g., "MAT"):', 'info');
                    let symbol = await this.promptTerminalInput('Enter token symbol (e.g., "MAT"):');
                    symbol = symbol ? symbol.trim() : '';
                    if (!symbol) {
                        this.log('Token creation cancelled.', 'warning');
                        return;
                    }
                    document.getElementById('commandInput').value = '';

                    // Get decimals
                    this.log('Enter decimals (default 18):', 'info');
                    let decimalsInput = await this.promptTerminalInput('Enter decimals (default 18):');
                    decimalsInput = decimalsInput ? decimalsInput.trim() : '';
                    let decimals = 18;
                    if (decimalsInput) {
                        const parsed = parseInt(decimalsInput);
                        if (!isNaN(parsed) && parsed >= 0 && parsed <= 36) decimals = parsed;
                    }
                    document.getElementById('commandInput').value = '';

                    // Get initial supply
                    this.log('Enter initial supply (e.g., 1000000):', 'info');
                    let supplyInput = await this.promptTerminalInput('Enter initial supply (e.g., 1000000):');
                    supplyInput = supplyInput ? supplyInput.trim() : '';
                    if (!supplyInput) {
                        this.log('Token creation cancelled.', 'warning');
                        return;
                    }
                    document.getElementById('commandInput').value = '';
                    const initialSupply = this.ethers.BigNumber.from(supplyInput);
                    if (initialSupply.lte(0)) {
                        this.log('Invalid supply amount. Please enter a positive number.', 'error');
                        return;
                    }

                    // Get mintable
                    this.log('Mintable? (yes/no, default yes):', 'info');
                    let mintableInput = await this.promptTerminalInput('Mintable? (yes/no, default yes):');
                    mintableInput = mintableInput ? mintableInput.trim().toLowerCase() : '';
                    let mintable = true;
                    if (mintableInput === 'no' || mintableInput === 'false') mintable = false;
                    document.getElementById('commandInput').value = '';

                    // Get pausable
                    this.log('Pausable? (yes/no, default yes):', 'info');
                    let pausableInput = await this.promptTerminalInput('Pausable? (yes/no, default yes):');
                    pausableInput = pausableInput ? pausableInput.trim().toLowerCase() : '';
                    let pausable = true;
                    if (pausableInput === 'no' || pausableInput === 'false') pausable = false;
                    document.getElementById('commandInput').value = '';

                    this.log('', 'info');
                    this.log('📋 Token Details:', 'info');
                    this.log(`Name: ${name}`, 'output');
                    this.log(`Symbol: ${symbol}`, 'output');
                    this.log(`Decimals: ${decimals}`, 'output');
                    this.log(`Initial Supply: ${initialSupply.toLocaleString()}`, 'output');
                    this.log(`Mintable: ${mintable ? 'Yes' : 'No'}`, 'output');
                    this.log(`Pausable: ${pausable ? 'Yes' : 'No'}`, 'output');
                    this.log('', 'info');

                    this.log('Deploy token? (yes/no):', 'info');
                    let confirm = await this.promptTerminalInput('Deploy token? (yes/no):');
                    confirm = confirm ? confirm.trim().toLowerCase() : '';
                    if (confirm !== 'yes') {
                        this.log('Token creation cancelled.', 'warning');
                        return;
                    }
                    document.getElementById('commandInput').value = '';

                    this.log('⏳ Deploying token...', 'info');

                    // Create contract instance
                    const factory = new this.ethers.Contract(FACTORY_ADDRESS, FACTORY_ABI, this.signer);

                    try {
                        // Deploy token
                        const tx = await factory.createToken(name, symbol, decimals, initialSupply, mintable, pausable);
                        this.log(`Transaction sent: ${tx.hash}`, 'info');

                        // Wait for confirmation
                        const receipt = await tx.wait();
                        this.log('✅ Token deployed successfully!', 'success');
                        this.log('', 'info');

                        // Extract token address from events
                        let tokenAddress = null;
                        for (const log of receipt.logs) {
                            try {
                                const parsedLog = factory.interface.parseLog(log);
                                if (parsedLog.name === 'TokenCreated') {
                                    tokenAddress = parsedLog.args.token;
                                    break;
                                }
                            } catch (e) {
                                // Continue searching
                            }
                        }

                        if (tokenAddress) {
                            this.logHtml('<span class="success">🎉 <b>Token Deployed!</b></span>', 'success');
                            this.logHtml(`Token Address: <span class="copyable" onclick="navigator.clipboard.writeText('${tokenAddress}')" style="color:#33bbff;cursor:pointer;">${tokenAddress}</span>`, 'output');
                            this.logHtml(`Transaction Hash: <span class="copyable" onclick="navigator.clipboard.writeText('${tx.hash}')" style="color:#33bbff;cursor:pointer;">${tx.hash}</span>`, 'output');
                            this.logHtml(`<b>Name:</b> ${name}<br><b>Symbol:</b> ${symbol}<br><b>Decimals:</b> ${decimals}<br><b>Initial Supply:</b> ${initialSupply.toString()}<br><b>Mintable:</b> ${mintable ? 'Yes' : 'No'}<br><b>Pausable:</b> ${pausable ? 'Yes' : 'No'}`, 'output');
                            this.logHtml('<span style="color:#99ccff">💡 You can now add liquidity or trade your token!</span>', 'info');
                        } else {
                            this.logHtml('<span class="warning">⚠️ Token deployed but address not found in events</span>', 'warning');
                            this.logHtml(`Transaction Hash: <span class="copyable" onclick="navigator.clipboard.writeText('${tx.hash}')" style="color:#33bbff;cursor:pointer;">${tx.hash}</span>`, 'output');
                        }

                    } catch (error) {
                        this.log(`❌ Token creation failed: ${error.message}`, 'error');
                        if (error.code === 'ACTION_REJECTED') {
                            this.log('Transaction was rejected by user.', 'warning');
                        } else if (error.code === 'INSUFFICIENT_FUNDS') {
                            this.log('Insufficient funds for gas fees.', 'error');
                        } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                            this.log('Tip: Check that the contract address, ABI, and network are correct. Make sure MetaMask is on the right network and the contract is deployed.', 'warning');
                        }
                    }
                } catch (error) {
                    this.log(`❌ Token creation failed: ${error.message}`, 'error');
                    if (error.code === 'ACTION_REJECTED') {
                        this.log('Transaction was rejected by user.', 'warning');
                    } else if (error.code === 'INSUFFICIENT_FUNDS') {
                        this.log('Insufficient funds for gas fees.', 'error');
                    }
                }
            }
        }

        // Add this helper function to fund the Omega wallet via relayer
        async function fundOmegaWallet(address) {
            try {
                const response = await fetch(`${RELAYER_URL}/fund`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ address, amount: '0.1' })
                });
                const data = await response.json();
                if (data.success) {
                    window.terminal.log(`✅ Your wallet is being funded! Tx: ${data.txHash}`, 'success');
                    window.terminal.log('Please wait a few seconds before using your wallet.', 'info');
                } else {
                    window.terminal.log('❌ Funding failed: ' + (data.error || 'Unknown error'), 'error');
                }
            } catch (err) {
                window.terminal.log('❌ Funding request failed: ' + err.message, 'error');
            }
        }
    </script>
    <script>
        window.terminal = new OmegaMinerTerminal();
    </script>
</body>
</html>
